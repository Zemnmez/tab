// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package resolver

import (
	"fmt"
	"io"
	"net/url"
	"strconv"
	"time"

	"github.com/zemnmez/tab/types"
)

type AuthClient interface {
	IsAuthClient()
}

type Authentication interface {
	IsAuthentication()
}

type AuthorizationGrantee interface {
	IsAuthorizationGrantee()
}

type AuthorizationGranter interface {
	IsAuthorizationGranter()
}

type Authorized interface {
	IsAuthorized()
}

type SingletonUser interface {
	IsSingletonUser()
}

type Timestamped interface {
	IsTimestamped()
}

// An OAuth2RefreshToken within the OAuth2.0 concept is a long-lived
// bearer token that can be exchanged for an OAuth 2.0 token.
//
// Its purpose is to be long lived but infrequently transmitted,
// lessening its chance of exposure.
type AuthorizationRefreshTokenInfo struct {
	ID                 string              `json:"ID"`
	Token              string              `json:"Token"`
	AuthorizationGrant *AuthorizationGrant `json:"AuthorizationGrant"`
	Expires            *time.Time          `json:"Expires"`
	Created            time.Time           `json:"Created"`
}

// An OAuth2Token is a concept within OAuth 2.0 which is a short-lived
// bearer token encapsulating some permissions. The short lived nature
// of the token reduces its exposure.
//
// An OAuth2Token can be retreieved by going through an OAuth grant flow
// or using a refresh token.
type AuthorizationTokenInfo struct {
	ID                 string              `json:"ID"`
	Token              string              `json:"Token"`
	AuthorizationGrant *AuthorizationGrant `json:"AuthorizationGrant"`
	Expires            time.Time           `json:"Expires"`
	Created            time.Time           `json:"Created"`
}

type AuthzQuery struct {
	TokenInfo        *AuthorizationTokenInfo        `json:"TokenInfo"`
	TokenInfoByID    *AuthorizationTokenInfo        `json:"TokenInfoByID"`
	RefreshToken     *AuthorizationRefreshTokenInfo `json:"RefreshToken"`
	RefreshTokenByID *AuthorizationRefreshTokenInfo `json:"RefreshTokenByID"`
	Token            *AuthorizationTokenInfo        `json:"Token"`
}

type ConnectionsMutation struct {
	Link   *Link `json:"Link"`
	Unlink *Link `json:"Unlink"`
}

type ConnectionsQuery struct {
	Links []*Link `json:"Links"`
}

type DefinedItemInput struct {
	Name     string       `json:"Name"`
	Location string       `json:"Location"`
	Parent   *ItemInput   `json:"Parent"`
	Children []*ItemInput `json:"Children"`
}

// The FirstParty client represents the website itself. It naturally has all authorizations at all times.
type FirstParty struct {
	ID string `json:"ID"`
	// The FirstParty OAuth client is owned by the ROOT user.
	Owner            types.UserID          `json:"Owner"`
	RedirectURI      url.URL               `json:"RedirectURI"`
	AuthorizationFor []*AuthorizationGrant `json:"AuthorizationFor"`
	// Abilities granted to this client by some entity.
	GrantsReceived []*AuthorizationGrant `json:"GrantsReceived"`
}

func (FirstParty) IsAuthClient()           {}
func (FirstParty) IsAuthorizationGrantee() {}

type ItemInput struct {
	ByID          *types.ItemID     `json:"ById"`
	WithStructure *DefinedItemInput `json:"WithStructure"`
}

type OIDCProviderInput struct {
	Name string `json:"Name"`
}

type RegularUserMutator struct {
	Modify User `json:"Modify"`
}

func (RegularUserMutator) IsUserMutator() {}

type Self struct {
	ID             types.UserID        `json:"ID"`
	Name           string              `json:"Name"`
	Authentication *UserAuthentication `json:"Authentication"`
	// The abilities granted by this entity.
	GrantsGiven []*AuthorizationGrant `json:"GrantsGiven"`
	// The abilities granted to this entity.
	GrantsReceived []*AuthorizationGrant `json:"GrantsReceived"`
	Authorizations []types.Authorization `json:"Authorizations"`
	History        []*HistoryItem        `json:"History"`
	Created        time.Time             `json:"Created"`
	Modified       time.Time             `json:"Modified"`
	Links          []*Link               `json:"Links"`
}

func (Self) IsUser()                 {}
func (Self) IsAuthorizationGranter() {}
func (Self) IsAuthorizationGrantee() {}
func (Self) IsAuthorized()           {}
func (Self) IsTimestamped()          {}

type SingletonUserMutator struct {
	Modify User `json:"Modify"`
}

func (SingletonUserMutator) IsUserMutator() {}

type ThirdParty struct {
	ID string `json:"ID"`
	// The creator of this AuthClient.
	Owner            types.UserID          `json:"Owner"`
	RedirectURI      url.URL               `json:"RedirectURI"`
	AuthorizationFor []*AuthorizationGrant `json:"AuthorizationFor"`
	// Abilities granted to this client by some entity.
	GrantsReceived []*AuthorizationGrant `json:"GrantsReceived"`
}

func (ThirdParty) IsAuthClient()           {}
func (ThirdParty) IsAuthorizationGrantee() {}

type UserInput struct {
	Name string `json:"Name"`
}

type UserOIDCQuery struct {
	// Providers returns a list of auth providers supported by this user
	Providers []*types.OIDCProvider `json:"Providers"`
}

type SingletonUserType string

const (
	SingletonUserTypeSingletonusertypeNil SingletonUserType = "SINGLETONUSERTYPE_NIL"
	SingletonUserTypeRoot                 SingletonUserType = "ROOT"
	SingletonUserTypeAnonymous            SingletonUserType = "ANONYMOUS"
)

var AllSingletonUserType = []SingletonUserType{
	SingletonUserTypeSingletonusertypeNil,
	SingletonUserTypeRoot,
	SingletonUserTypeAnonymous,
}

func (e SingletonUserType) IsValid() bool {
	switch e {
	case SingletonUserTypeSingletonusertypeNil, SingletonUserTypeRoot, SingletonUserTypeAnonymous:
		return true
	}
	return false
}

func (e SingletonUserType) String() string {
	return string(e)
}

func (e *SingletonUserType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SingletonUserType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SingletonUserType", str)
	}
	return nil
}

func (e SingletonUserType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}
