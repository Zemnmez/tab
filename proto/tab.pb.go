// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: proto/tab.proto

package tab

import (
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
	reflect "reflect"
	strconv "strconv"
	strings "strings"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type Authorization int32

const (
	VIEW_USERS               Authorization = 0
	MODIFY_VALID_AUTH        Authorization = 1
	ADD_ITEMS                Authorization = 2
	MODIFY_OTHER_USERS       Authorization = 3
	MODIFY_SPECIAL_USERS     Authorization = 4
	MODIFY_SELF              Authorization = 5
	VIEW_OTHER_USERS_HISTORY Authorization = 6
	VIEW_OWN_HISTORY         Authorization = 7
)

var Authorization_name = map[int32]string{
	0: "VIEW_USERS",
	1: "MODIFY_VALID_AUTH",
	2: "ADD_ITEMS",
	3: "MODIFY_OTHER_USERS",
	4: "MODIFY_SPECIAL_USERS",
	5: "MODIFY_SELF",
	6: "VIEW_OTHER_USERS_HISTORY",
	7: "VIEW_OWN_HISTORY",
}

var Authorization_value = map[string]int32{
	"VIEW_USERS":               0,
	"MODIFY_VALID_AUTH":        1,
	"ADD_ITEMS":                2,
	"MODIFY_OTHER_USERS":       3,
	"MODIFY_SPECIAL_USERS":     4,
	"MODIFY_SELF":              5,
	"VIEW_OTHER_USERS_HISTORY": 6,
	"VIEW_OWN_HISTORY":         7,
}

func (Authorization) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_f1516b12a244c06b, []int{0}
}

type SpecialUserID int32

const (
	ROOT      SpecialUserID = 0
	ANONYMOUS SpecialUserID = 1
)

var SpecialUserID_name = map[int32]string{
	0: "ROOT",
	1: "ANONYMOUS",
}

var SpecialUserID_value = map[string]int32{
	"ROOT":      0,
	"ANONYMOUS": 1,
}

func (SpecialUserID) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_f1516b12a244c06b, []int{1}
}

type ID struct {
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
}

func (m *ID) Reset()      { *m = ID{} }
func (*ID) ProtoMessage() {}
func (*ID) Descriptor() ([]byte, []int) {
	return fileDescriptor_f1516b12a244c06b, []int{0}
}
func (m *ID) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ID) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ID.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ID) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ID.Merge(m, src)
}
func (m *ID) XXX_Size() int {
	return m.Size()
}
func (m *ID) XXX_DiscardUnknown() {
	xxx_messageInfo_ID.DiscardUnknown(m)
}

var xxx_messageInfo_ID proto.InternalMessageInfo

func (m *ID) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

type UserID struct {
	// Types that are valid to be assigned to ID:
	//	*UserID_SpecialUserID
	//	*UserID_RegularUserID
	ID isUserID_ID `protobuf_oneof:"ID"`
}

func (m *UserID) Reset()      { *m = UserID{} }
func (*UserID) ProtoMessage() {}
func (*UserID) Descriptor() ([]byte, []int) {
	return fileDescriptor_f1516b12a244c06b, []int{1}
}
func (m *UserID) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UserID) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UserID.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UserID) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UserID.Merge(m, src)
}
func (m *UserID) XXX_Size() int {
	return m.Size()
}
func (m *UserID) XXX_DiscardUnknown() {
	xxx_messageInfo_UserID.DiscardUnknown(m)
}

var xxx_messageInfo_UserID proto.InternalMessageInfo

type isUserID_ID interface {
	isUserID_ID()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type UserID_SpecialUserID struct {
	SpecialUserID SpecialUserID `protobuf:"varint,1,opt,name=specialUserID,proto3,enum=tab.SpecialUserID,oneof"`
}
type UserID_RegularUserID struct {
	RegularUserID *RegularUserID `protobuf:"bytes,2,opt,name=regularUserID,proto3,oneof"`
}

func (*UserID_SpecialUserID) isUserID_ID() {}
func (*UserID_RegularUserID) isUserID_ID() {}

func (m *UserID) GetID() isUserID_ID {
	if m != nil {
		return m.ID
	}
	return nil
}

func (m *UserID) GetSpecialUserID() SpecialUserID {
	if x, ok := m.GetID().(*UserID_SpecialUserID); ok {
		return x.SpecialUserID
	}
	return ROOT
}

func (m *UserID) GetRegularUserID() *RegularUserID {
	if x, ok := m.GetID().(*UserID_RegularUserID); ok {
		return x.RegularUserID
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*UserID) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*UserID_SpecialUserID)(nil),
		(*UserID_RegularUserID)(nil),
	}
}

type HistoryID struct {
	Id *ID `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
}

func (m *HistoryID) Reset()      { *m = HistoryID{} }
func (*HistoryID) ProtoMessage() {}
func (*HistoryID) Descriptor() ([]byte, []int) {
	return fileDescriptor_f1516b12a244c06b, []int{2}
}
func (m *HistoryID) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HistoryID) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_HistoryID.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *HistoryID) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HistoryID.Merge(m, src)
}
func (m *HistoryID) XXX_Size() int {
	return m.Size()
}
func (m *HistoryID) XXX_DiscardUnknown() {
	xxx_messageInfo_HistoryID.DiscardUnknown(m)
}

var xxx_messageInfo_HistoryID proto.InternalMessageInfo

func (m *HistoryID) GetId() *ID {
	if m != nil {
		return m.Id
	}
	return nil
}

type RegularUserID struct {
	Id *ID `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
}

func (m *RegularUserID) Reset()      { *m = RegularUserID{} }
func (*RegularUserID) ProtoMessage() {}
func (*RegularUserID) Descriptor() ([]byte, []int) {
	return fileDescriptor_f1516b12a244c06b, []int{3}
}
func (m *RegularUserID) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RegularUserID) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RegularUserID.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RegularUserID) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RegularUserID.Merge(m, src)
}
func (m *RegularUserID) XXX_Size() int {
	return m.Size()
}
func (m *RegularUserID) XXX_DiscardUnknown() {
	xxx_messageInfo_RegularUserID.DiscardUnknown(m)
}

var xxx_messageInfo_RegularUserID proto.InternalMessageInfo

func (m *RegularUserID) GetId() *ID {
	if m != nil {
		return m.Id
	}
	return nil
}

type RegularUser struct {
	Id             *UserID         `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	Name           string          `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	Authorizations []Authorization `protobuf:"varint,3,rep,packed,name=authorizations,proto3,enum=tab.Authorization" json:"authorizations,omitempty"`
	HistoryID      []HistoryID     `protobuf:"bytes,4,rep,name=historyID,proto3" json:"historyID"`
}

func (m *RegularUser) Reset()      { *m = RegularUser{} }
func (*RegularUser) ProtoMessage() {}
func (*RegularUser) Descriptor() ([]byte, []int) {
	return fileDescriptor_f1516b12a244c06b, []int{4}
}
func (m *RegularUser) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RegularUser) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RegularUser.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RegularUser) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RegularUser.Merge(m, src)
}
func (m *RegularUser) XXX_Size() int {
	return m.Size()
}
func (m *RegularUser) XXX_DiscardUnknown() {
	xxx_messageInfo_RegularUser.DiscardUnknown(m)
}

var xxx_messageInfo_RegularUser proto.InternalMessageInfo

func (m *RegularUser) GetId() *UserID {
	if m != nil {
		return m.Id
	}
	return nil
}

func (m *RegularUser) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *RegularUser) GetAuthorizations() []Authorization {
	if m != nil {
		return m.Authorizations
	}
	return nil
}

func (m *RegularUser) GetHistoryID() []HistoryID {
	if m != nil {
		return m.HistoryID
	}
	return nil
}

type SpecialUser struct {
	Id             SpecialUserID   `protobuf:"varint,1,opt,name=id,proto3,enum=tab.SpecialUserID" json:"id,omitempty"`
	Authorizations []Authorization `protobuf:"varint,2,rep,packed,name=authorizations,proto3,enum=tab.Authorization" json:"authorizations,omitempty"`
	HistoryID      []HistoryID     `protobuf:"bytes,3,rep,name=historyID,proto3" json:"historyID"`
}

func (m *SpecialUser) Reset()      { *m = SpecialUser{} }
func (*SpecialUser) ProtoMessage() {}
func (*SpecialUser) Descriptor() ([]byte, []int) {
	return fileDescriptor_f1516b12a244c06b, []int{5}
}
func (m *SpecialUser) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SpecialUser) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SpecialUser.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SpecialUser) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SpecialUser.Merge(m, src)
}
func (m *SpecialUser) XXX_Size() int {
	return m.Size()
}
func (m *SpecialUser) XXX_DiscardUnknown() {
	xxx_messageInfo_SpecialUser.DiscardUnknown(m)
}

var xxx_messageInfo_SpecialUser proto.InternalMessageInfo

func (m *SpecialUser) GetId() SpecialUserID {
	if m != nil {
		return m.Id
	}
	return ROOT
}

func (m *SpecialUser) GetAuthorizations() []Authorization {
	if m != nil {
		return m.Authorizations
	}
	return nil
}

func (m *SpecialUser) GetHistoryID() []HistoryID {
	if m != nil {
		return m.HistoryID
	}
	return nil
}

type AuthorizationGrant struct {
	From *UserID         `protobuf:"bytes,1,opt,name=from,proto3" json:"from,omitempty"`
	Of   []Authorization `protobuf:"varint,2,rep,packed,name=Of,json=of,proto3,enum=tab.Authorization" json:"Of,omitempty"`
}

func (m *AuthorizationGrant) Reset()      { *m = AuthorizationGrant{} }
func (*AuthorizationGrant) ProtoMessage() {}
func (*AuthorizationGrant) Descriptor() ([]byte, []int) {
	return fileDescriptor_f1516b12a244c06b, []int{6}
}
func (m *AuthorizationGrant) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AuthorizationGrant) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AuthorizationGrant.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AuthorizationGrant) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AuthorizationGrant.Merge(m, src)
}
func (m *AuthorizationGrant) XXX_Size() int {
	return m.Size()
}
func (m *AuthorizationGrant) XXX_DiscardUnknown() {
	xxx_messageInfo_AuthorizationGrant.DiscardUnknown(m)
}

var xxx_messageInfo_AuthorizationGrant proto.InternalMessageInfo

func (m *AuthorizationGrant) GetFrom() *UserID {
	if m != nil {
		return m.From
	}
	return nil
}

func (m *AuthorizationGrant) GetOf() []Authorization {
	if m != nil {
		return m.Of
	}
	return nil
}

func init() {
	proto.RegisterEnum("tab.Authorization", Authorization_name, Authorization_value)
	proto.RegisterEnum("tab.SpecialUserID", SpecialUserID_name, SpecialUserID_value)
	proto.RegisterType((*ID)(nil), "tab.ID")
	proto.RegisterType((*UserID)(nil), "tab.UserID")
	proto.RegisterType((*HistoryID)(nil), "tab.HistoryID")
	proto.RegisterType((*RegularUserID)(nil), "tab.RegularUserID")
	proto.RegisterType((*RegularUser)(nil), "tab.RegularUser")
	proto.RegisterType((*SpecialUser)(nil), "tab.SpecialUser")
	proto.RegisterType((*AuthorizationGrant)(nil), "tab.AuthorizationGrant")
}

func init() { proto.RegisterFile("proto/tab.proto", fileDescriptor_f1516b12a244c06b) }

var fileDescriptor_f1516b12a244c06b = []byte{
	// 558 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xa4, 0x93, 0x3f, 0x6f, 0xd3, 0x5c,
	0x14, 0xc6, 0x7d, 0x6d, 0xbf, 0xed, 0x9b, 0x63, 0x25, 0x35, 0x47, 0x01, 0x22, 0x40, 0xb7, 0x51,
	0xc4, 0x60, 0x75, 0x48, 0x20, 0xed, 0xc4, 0xd4, 0x04, 0xbb, 0xc4, 0x52, 0x12, 0x23, 0x3b, 0x69,
	0x95, 0xc9, 0x72, 0xda, 0xfc, 0xb1, 0xd4, 0xc4, 0x95, 0xe3, 0x20, 0xc1, 0xc4, 0xc4, 0xcc, 0xb7,
	0x80, 0x0f, 0xc0, 0xc8, 0x07, 0xe8, 0x98, 0xb1, 0x13, 0x22, 0xce, 0xc2, 0xd8, 0x8f, 0x80, 0x7c,
	0xe3, 0x06, 0x1b, 0x8a, 0x40, 0x62, 0x3b, 0x3a, 0xcf, 0xf3, 0x9c, 0xfb, 0xbb, 0xe7, 0xea, 0xc2,
	0xce, 0x85, 0xef, 0x05, 0x5e, 0x25, 0x70, 0xfa, 0x65, 0x56, 0xa1, 0x10, 0x38, 0xfd, 0x07, 0x07,
	0x23, 0x37, 0x18, 0xcf, 0xfb, 0xe5, 0x53, 0x6f, 0x52, 0x19, 0x79, 0x23, 0xaf, 0xc2, 0xb4, 0xfe,
	0x7c, 0x78, 0xf8, 0xea, 0x69, 0x79, 0xbf, 0xfc, 0x84, 0x35, 0xd7, 0xc9, 0xa8, 0x5a, 0x47, 0x4b,
	0x79, 0xe0, 0x75, 0x15, 0x73, 0xc0, 0xbb, 0x67, 0x05, 0x52, 0x24, 0x4a, 0xc6, 0xe4, 0xdd, 0xb3,
	0xd2, 0x3b, 0x02, 0x5b, 0xdd, 0xd9, 0xc0, 0xd7, 0x55, 0x7c, 0x06, 0xd9, 0xd9, 0xc5, 0xe0, 0xd4,
	0x75, 0xce, 0xd7, 0x0d, 0xe6, 0xca, 0x55, 0xb1, 0x1c, 0x1d, 0x6f, 0x25, 0x95, 0x06, 0x67, 0xa6,
	0xad, 0x51, 0xd6, 0x1f, 0x8c, 0xe6, 0xe7, 0x8e, 0x1f, 0x67, 0xf9, 0x22, 0x51, 0xa4, 0x38, 0x6b,
	0x26, 0x95, 0x28, 0x9b, 0xb2, 0xd6, 0xc5, 0x08, 0xac, 0xf4, 0x18, 0x32, 0x0d, 0x77, 0x16, 0x78,
	0xfe, 0x6b, 0x5d, 0xc5, 0xfb, 0x1b, 0x4a, 0xa9, 0xba, 0xcd, 0x66, 0xe8, 0x2a, 0xc3, 0x55, 0x20,
	0x9b, 0x9a, 0xf6, 0x7b, 0xe7, 0x27, 0x02, 0x52, 0xc2, 0x8a, 0x0f, 0x13, 0x46, 0x89, 0x19, 0xd7,
	0x13, 0x22, 0x33, 0x22, 0x88, 0x53, 0x67, 0x32, 0x60, 0xd4, 0x19, 0x93, 0xd5, 0x78, 0x08, 0x39,
	0x67, 0x1e, 0x8c, 0x3d, 0xdf, 0x7d, 0xe3, 0x04, 0xae, 0x37, 0x9d, 0x15, 0x84, 0xa2, 0xb0, 0xd9,
	0x47, 0x2d, 0x29, 0xd5, 0xc5, 0xcb, 0x2f, 0xbb, 0x9c, 0xf9, 0x93, 0x1f, 0xab, 0x90, 0x19, 0xdf,
	0x5c, 0xa9, 0x20, 0x16, 0x05, 0x45, 0xaa, 0xe6, 0x58, 0x78, 0x73, 0xd1, 0x38, 0xf8, 0xc3, 0x56,
	0xfa, 0x40, 0x40, 0x4a, 0xec, 0x1a, 0x4b, 0x1b, 0xec, 0x5b, 0x5f, 0x82, 0xd1, 0xff, 0x4a, 0xca,
	0xff, 0x0b, 0xa9, 0xf0, 0x77, 0xa4, 0x36, 0x60, 0x6a, 0xf4, 0x0b, 0xdf, 0x99, 0x06, 0xb8, 0x0b,
	0xe2, 0xd0, 0xf7, 0x26, 0xb7, 0x2d, 0x9a, 0x09, 0xa8, 0x00, 0x6f, 0x0c, 0xff, 0x08, 0xc8, 0x7b,
	0xc3, 0xbd, 0xcf, 0x04, 0xb2, 0x29, 0x0d, 0x73, 0x00, 0xc7, 0xba, 0x76, 0x62, 0x77, 0x2d, 0xcd,
	0xb4, 0x64, 0x0e, 0xef, 0xc2, 0x9d, 0x96, 0xa1, 0xea, 0x47, 0x3d, 0xfb, 0xb8, 0xd6, 0xd4, 0x55,
	0xbb, 0xd6, 0xed, 0x34, 0x64, 0x82, 0x59, 0xc8, 0xd4, 0x54, 0xd5, 0xd6, 0x3b, 0x5a, 0xcb, 0x92,
	0x79, 0xbc, 0x07, 0x18, 0xbb, 0x8c, 0x4e, 0x43, 0x33, 0xe3, 0xb4, 0x80, 0x05, 0xc8, 0xc7, 0x7d,
	0xeb, 0xa5, 0xf6, 0x5c, 0xaf, 0x35, 0x63, 0x45, 0xc4, 0x1d, 0x90, 0x6e, 0x14, 0xad, 0x79, 0x24,
	0xff, 0x87, 0x8f, 0xa0, 0xc0, 0x0e, 0x4e, 0x0c, 0xb0, 0x1b, 0xba, 0xd5, 0x31, 0xcc, 0x9e, 0xbc,
	0x85, 0x79, 0x90, 0xd7, 0xea, 0x49, 0x7b, 0xd3, 0xdd, 0xde, 0x53, 0x20, 0x9b, 0x7a, 0x2a, 0xfc,
	0x1f, 0x44, 0xd3, 0x30, 0x3a, 0x32, 0xc7, 0x00, 0xdb, 0x46, 0xbb, 0xd7, 0x32, 0xba, 0x96, 0x4c,
	0xea, 0x07, 0x8b, 0x25, 0xe5, 0xae, 0x96, 0x94, 0xbb, 0x5e, 0x52, 0xf2, 0x36, 0xa4, 0xe4, 0x63,
	0x48, 0xc9, 0x65, 0x48, 0xc9, 0x22, 0xa4, 0xe4, 0x6b, 0x48, 0xc9, 0xb7, 0x90, 0x72, 0xd7, 0x21,
	0x25, 0xef, 0x57, 0x94, 0x5b, 0xac, 0x28, 0x77, 0xb5, 0xa2, 0x5c, 0x7f, 0x8b, 0x7d, 0xeb, 0xfd,
	0xef, 0x01, 0x00, 0x00, 0xff, 0xff, 0x9f, 0xdb, 0x99, 0x12, 0x24, 0x04, 0x00, 0x00,
}

func (x Authorization) String() string {
	s, ok := Authorization_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x SpecialUserID) String() string {
	s, ok := SpecialUserID_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (this *ID) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ID)
	if !ok {
		that2, ok := that.(ID)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Id != that1.Id {
		return false
	}
	return true
}
func (this *UserID) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*UserID)
	if !ok {
		that2, ok := that.(UserID)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.ID == nil {
		if this.ID != nil {
			return false
		}
	} else if this.ID == nil {
		return false
	} else if !this.ID.Equal(that1.ID) {
		return false
	}
	return true
}
func (this *UserID_SpecialUserID) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*UserID_SpecialUserID)
	if !ok {
		that2, ok := that.(UserID_SpecialUserID)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.SpecialUserID != that1.SpecialUserID {
		return false
	}
	return true
}
func (this *UserID_RegularUserID) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*UserID_RegularUserID)
	if !ok {
		that2, ok := that.(UserID_RegularUserID)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.RegularUserID.Equal(that1.RegularUserID) {
		return false
	}
	return true
}
func (this *HistoryID) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*HistoryID)
	if !ok {
		that2, ok := that.(HistoryID)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Id.Equal(that1.Id) {
		return false
	}
	return true
}
func (this *RegularUserID) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RegularUserID)
	if !ok {
		that2, ok := that.(RegularUserID)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Id.Equal(that1.Id) {
		return false
	}
	return true
}
func (this *RegularUser) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RegularUser)
	if !ok {
		that2, ok := that.(RegularUser)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Id.Equal(that1.Id) {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if len(this.Authorizations) != len(that1.Authorizations) {
		return false
	}
	for i := range this.Authorizations {
		if this.Authorizations[i] != that1.Authorizations[i] {
			return false
		}
	}
	if len(this.HistoryID) != len(that1.HistoryID) {
		return false
	}
	for i := range this.HistoryID {
		if !this.HistoryID[i].Equal(&that1.HistoryID[i]) {
			return false
		}
	}
	return true
}
func (this *SpecialUser) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SpecialUser)
	if !ok {
		that2, ok := that.(SpecialUser)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Id != that1.Id {
		return false
	}
	if len(this.Authorizations) != len(that1.Authorizations) {
		return false
	}
	for i := range this.Authorizations {
		if this.Authorizations[i] != that1.Authorizations[i] {
			return false
		}
	}
	if len(this.HistoryID) != len(that1.HistoryID) {
		return false
	}
	for i := range this.HistoryID {
		if !this.HistoryID[i].Equal(&that1.HistoryID[i]) {
			return false
		}
	}
	return true
}
func (this *AuthorizationGrant) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AuthorizationGrant)
	if !ok {
		that2, ok := that.(AuthorizationGrant)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.From.Equal(that1.From) {
		return false
	}
	if len(this.Of) != len(that1.Of) {
		return false
	}
	for i := range this.Of {
		if this.Of[i] != that1.Of[i] {
			return false
		}
	}
	return true
}
func (this *ID) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&tab.ID{")
	s = append(s, "Id: "+fmt.Sprintf("%#v", this.Id)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *UserID) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&tab.UserID{")
	if this.ID != nil {
		s = append(s, "ID: "+fmt.Sprintf("%#v", this.ID)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *UserID_SpecialUserID) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&tab.UserID_SpecialUserID{` +
		`SpecialUserID:` + fmt.Sprintf("%#v", this.SpecialUserID) + `}`}, ", ")
	return s
}
func (this *UserID_RegularUserID) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&tab.UserID_RegularUserID{` +
		`RegularUserID:` + fmt.Sprintf("%#v", this.RegularUserID) + `}`}, ", ")
	return s
}
func (this *HistoryID) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&tab.HistoryID{")
	if this.Id != nil {
		s = append(s, "Id: "+fmt.Sprintf("%#v", this.Id)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *RegularUserID) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&tab.RegularUserID{")
	if this.Id != nil {
		s = append(s, "Id: "+fmt.Sprintf("%#v", this.Id)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *RegularUser) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&tab.RegularUser{")
	if this.Id != nil {
		s = append(s, "Id: "+fmt.Sprintf("%#v", this.Id)+",\n")
	}
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	s = append(s, "Authorizations: "+fmt.Sprintf("%#v", this.Authorizations)+",\n")
	if this.HistoryID != nil {
		vs := make([]*HistoryID, len(this.HistoryID))
		for i := range vs {
			vs[i] = &this.HistoryID[i]
		}
		s = append(s, "HistoryID: "+fmt.Sprintf("%#v", vs)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *SpecialUser) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&tab.SpecialUser{")
	s = append(s, "Id: "+fmt.Sprintf("%#v", this.Id)+",\n")
	s = append(s, "Authorizations: "+fmt.Sprintf("%#v", this.Authorizations)+",\n")
	if this.HistoryID != nil {
		vs := make([]*HistoryID, len(this.HistoryID))
		for i := range vs {
			vs[i] = &this.HistoryID[i]
		}
		s = append(s, "HistoryID: "+fmt.Sprintf("%#v", vs)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *AuthorizationGrant) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&tab.AuthorizationGrant{")
	if this.From != nil {
		s = append(s, "From: "+fmt.Sprintf("%#v", this.From)+",\n")
	}
	s = append(s, "Of: "+fmt.Sprintf("%#v", this.Of)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func valueToGoStringTab(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}
func (m *ID) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ID) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ID) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintTab(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *UserID) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UserID) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UserID) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ID != nil {
		{
			size := m.ID.Size()
			i -= size
			if _, err := m.ID.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *UserID_SpecialUserID) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *UserID_SpecialUserID) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i = encodeVarintTab(dAtA, i, uint64(m.SpecialUserID))
	i--
	dAtA[i] = 0x8
	return len(dAtA) - i, nil
}
func (m *UserID_RegularUserID) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *UserID_RegularUserID) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.RegularUserID != nil {
		{
			size, err := m.RegularUserID.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTab(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *HistoryID) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HistoryID) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HistoryID) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Id != nil {
		{
			size, err := m.Id.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTab(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RegularUserID) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RegularUserID) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RegularUserID) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Id != nil {
		{
			size, err := m.Id.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTab(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RegularUser) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RegularUser) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RegularUser) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.HistoryID) > 0 {
		for iNdEx := len(m.HistoryID) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.HistoryID[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTab(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.Authorizations) > 0 {
		dAtA5 := make([]byte, len(m.Authorizations)*10)
		var j4 int
		for _, num := range m.Authorizations {
			for num >= 1<<7 {
				dAtA5[j4] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j4++
			}
			dAtA5[j4] = uint8(num)
			j4++
		}
		i -= j4
		copy(dAtA[i:], dAtA5[:j4])
		i = encodeVarintTab(dAtA, i, uint64(j4))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintTab(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if m.Id != nil {
		{
			size, err := m.Id.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTab(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SpecialUser) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SpecialUser) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SpecialUser) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.HistoryID) > 0 {
		for iNdEx := len(m.HistoryID) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.HistoryID[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTab(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Authorizations) > 0 {
		dAtA8 := make([]byte, len(m.Authorizations)*10)
		var j7 int
		for _, num := range m.Authorizations {
			for num >= 1<<7 {
				dAtA8[j7] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j7++
			}
			dAtA8[j7] = uint8(num)
			j7++
		}
		i -= j7
		copy(dAtA[i:], dAtA8[:j7])
		i = encodeVarintTab(dAtA, i, uint64(j7))
		i--
		dAtA[i] = 0x12
	}
	if m.Id != 0 {
		i = encodeVarintTab(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *AuthorizationGrant) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AuthorizationGrant) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AuthorizationGrant) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Of) > 0 {
		dAtA10 := make([]byte, len(m.Of)*10)
		var j9 int
		for _, num := range m.Of {
			for num >= 1<<7 {
				dAtA10[j9] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j9++
			}
			dAtA10[j9] = uint8(num)
			j9++
		}
		i -= j9
		copy(dAtA[i:], dAtA10[:j9])
		i = encodeVarintTab(dAtA, i, uint64(j9))
		i--
		dAtA[i] = 0x12
	}
	if m.From != nil {
		{
			size, err := m.From.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTab(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintTab(dAtA []byte, offset int, v uint64) int {
	offset -= sovTab(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *ID) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovTab(uint64(l))
	}
	return n
}

func (m *UserID) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ID != nil {
		n += m.ID.Size()
	}
	return n
}

func (m *UserID_SpecialUserID) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovTab(uint64(m.SpecialUserID))
	return n
}
func (m *UserID_RegularUserID) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RegularUserID != nil {
		l = m.RegularUserID.Size()
		n += 1 + l + sovTab(uint64(l))
	}
	return n
}
func (m *HistoryID) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != nil {
		l = m.Id.Size()
		n += 1 + l + sovTab(uint64(l))
	}
	return n
}

func (m *RegularUserID) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != nil {
		l = m.Id.Size()
		n += 1 + l + sovTab(uint64(l))
	}
	return n
}

func (m *RegularUser) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != nil {
		l = m.Id.Size()
		n += 1 + l + sovTab(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovTab(uint64(l))
	}
	if len(m.Authorizations) > 0 {
		l = 0
		for _, e := range m.Authorizations {
			l += sovTab(uint64(e))
		}
		n += 1 + sovTab(uint64(l)) + l
	}
	if len(m.HistoryID) > 0 {
		for _, e := range m.HistoryID {
			l = e.Size()
			n += 1 + l + sovTab(uint64(l))
		}
	}
	return n
}

func (m *SpecialUser) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovTab(uint64(m.Id))
	}
	if len(m.Authorizations) > 0 {
		l = 0
		for _, e := range m.Authorizations {
			l += sovTab(uint64(e))
		}
		n += 1 + sovTab(uint64(l)) + l
	}
	if len(m.HistoryID) > 0 {
		for _, e := range m.HistoryID {
			l = e.Size()
			n += 1 + l + sovTab(uint64(l))
		}
	}
	return n
}

func (m *AuthorizationGrant) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.From != nil {
		l = m.From.Size()
		n += 1 + l + sovTab(uint64(l))
	}
	if len(m.Of) > 0 {
		l = 0
		for _, e := range m.Of {
			l += sovTab(uint64(e))
		}
		n += 1 + sovTab(uint64(l)) + l
	}
	return n
}

func sovTab(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozTab(x uint64) (n int) {
	return sovTab(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *ID) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ID{`,
		`Id:` + fmt.Sprintf("%v", this.Id) + `,`,
		`}`,
	}, "")
	return s
}
func (this *UserID) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&UserID{`,
		`ID:` + fmt.Sprintf("%v", this.ID) + `,`,
		`}`,
	}, "")
	return s
}
func (this *UserID_SpecialUserID) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&UserID_SpecialUserID{`,
		`SpecialUserID:` + fmt.Sprintf("%v", this.SpecialUserID) + `,`,
		`}`,
	}, "")
	return s
}
func (this *UserID_RegularUserID) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&UserID_RegularUserID{`,
		`RegularUserID:` + strings.Replace(fmt.Sprintf("%v", this.RegularUserID), "RegularUserID", "RegularUserID", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *HistoryID) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&HistoryID{`,
		`Id:` + strings.Replace(this.Id.String(), "ID", "ID", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *RegularUserID) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&RegularUserID{`,
		`Id:` + strings.Replace(this.Id.String(), "ID", "ID", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *RegularUser) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForHistoryID := "[]HistoryID{"
	for _, f := range this.HistoryID {
		repeatedStringForHistoryID += strings.Replace(strings.Replace(f.String(), "HistoryID", "HistoryID", 1), `&`, ``, 1) + ","
	}
	repeatedStringForHistoryID += "}"
	s := strings.Join([]string{`&RegularUser{`,
		`Id:` + strings.Replace(this.Id.String(), "UserID", "UserID", 1) + `,`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`Authorizations:` + fmt.Sprintf("%v", this.Authorizations) + `,`,
		`HistoryID:` + repeatedStringForHistoryID + `,`,
		`}`,
	}, "")
	return s
}
func (this *SpecialUser) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForHistoryID := "[]HistoryID{"
	for _, f := range this.HistoryID {
		repeatedStringForHistoryID += strings.Replace(strings.Replace(f.String(), "HistoryID", "HistoryID", 1), `&`, ``, 1) + ","
	}
	repeatedStringForHistoryID += "}"
	s := strings.Join([]string{`&SpecialUser{`,
		`Id:` + fmt.Sprintf("%v", this.Id) + `,`,
		`Authorizations:` + fmt.Sprintf("%v", this.Authorizations) + `,`,
		`HistoryID:` + repeatedStringForHistoryID + `,`,
		`}`,
	}, "")
	return s
}
func (this *AuthorizationGrant) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AuthorizationGrant{`,
		`From:` + strings.Replace(this.From.String(), "UserID", "UserID", 1) + `,`,
		`Of:` + fmt.Sprintf("%v", this.Of) + `,`,
		`}`,
	}, "")
	return s
}
func valueToStringTab(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *ID) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTab
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ID: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ID: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTab
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTab
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTab
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTab(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTab
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTab
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UserID) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTab
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UserID: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UserID: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SpecialUserID", wireType)
			}
			var v SpecialUserID
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTab
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= SpecialUserID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ID = &UserID_SpecialUserID{v}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RegularUserID", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTab
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTab
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTab
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &RegularUserID{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ID = &UserID_RegularUserID{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTab(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTab
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTab
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HistoryID) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTab
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HistoryID: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HistoryID: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTab
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTab
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTab
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Id == nil {
				m.Id = &ID{}
			}
			if err := m.Id.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTab(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTab
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTab
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RegularUserID) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTab
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RegularUserID: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RegularUserID: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTab
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTab
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTab
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Id == nil {
				m.Id = &ID{}
			}
			if err := m.Id.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTab(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTab
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTab
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RegularUser) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTab
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RegularUser: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RegularUser: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTab
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTab
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTab
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Id == nil {
				m.Id = &UserID{}
			}
			if err := m.Id.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTab
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTab
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTab
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType == 0 {
				var v Authorization
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTab
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= Authorization(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Authorizations = append(m.Authorizations, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTab
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTab
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthTab
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				if elementCount != 0 && len(m.Authorizations) == 0 {
					m.Authorizations = make([]Authorization, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v Authorization
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTab
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= Authorization(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Authorizations = append(m.Authorizations, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Authorizations", wireType)
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HistoryID", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTab
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTab
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTab
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HistoryID = append(m.HistoryID, HistoryID{})
			if err := m.HistoryID[len(m.HistoryID)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTab(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTab
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTab
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SpecialUser) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTab
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SpecialUser: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SpecialUser: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTab
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= SpecialUserID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType == 0 {
				var v Authorization
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTab
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= Authorization(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Authorizations = append(m.Authorizations, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTab
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTab
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthTab
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				if elementCount != 0 && len(m.Authorizations) == 0 {
					m.Authorizations = make([]Authorization, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v Authorization
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTab
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= Authorization(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Authorizations = append(m.Authorizations, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Authorizations", wireType)
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HistoryID", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTab
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTab
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTab
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HistoryID = append(m.HistoryID, HistoryID{})
			if err := m.HistoryID[len(m.HistoryID)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTab(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTab
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTab
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AuthorizationGrant) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTab
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AuthorizationGrant: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AuthorizationGrant: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field From", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTab
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTab
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTab
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.From == nil {
				m.From = &UserID{}
			}
			if err := m.From.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType == 0 {
				var v Authorization
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTab
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= Authorization(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Of = append(m.Of, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTab
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTab
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthTab
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				if elementCount != 0 && len(m.Of) == 0 {
					m.Of = make([]Authorization, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v Authorization
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTab
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= Authorization(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Of = append(m.Of, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Of", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTab(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTab
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTab
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTab(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTab
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTab
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTab
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthTab
			}
			iNdEx += length
			if iNdEx < 0 {
				return 0, ErrInvalidLengthTab
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowTab
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipTab(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
				if iNdEx < 0 {
					return 0, ErrInvalidLengthTab
				}
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthTab = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTab   = fmt.Errorf("proto: integer overflow")
)
