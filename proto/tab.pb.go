// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: proto/tab.proto

package protos

import (
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	protobuf "google/protobuf"
	io "io"
	math "math"
	math_bits "math/bits"
	reflect "reflect"
	strconv "strconv"
	strings "strings"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type Authorization int32

const (
	VIEW_USERS               Authorization = 0
	MODIFY_VALID_AUTH        Authorization = 1
	ADD_ITEMS                Authorization = 2
	MODIFY_OTHER_USERS       Authorization = 3
	MODIFY_SPECIAL_USERS     Authorization = 4
	MODIFY_SELF              Authorization = 5
	VIEW_OTHER_USERS_HISTORY Authorization = 6
	VIEW_OWN_HISTORY         Authorization = 7
)

var Authorization_name = map[int32]string{
	0: "VIEW_USERS",
	1: "MODIFY_VALID_AUTH",
	2: "ADD_ITEMS",
	3: "MODIFY_OTHER_USERS",
	4: "MODIFY_SPECIAL_USERS",
	5: "MODIFY_SELF",
	6: "VIEW_OTHER_USERS_HISTORY",
	7: "VIEW_OWN_HISTORY",
}

var Authorization_value = map[string]int32{
	"VIEW_USERS":               0,
	"MODIFY_VALID_AUTH":        1,
	"ADD_ITEMS":                2,
	"MODIFY_OTHER_USERS":       3,
	"MODIFY_SPECIAL_USERS":     4,
	"MODIFY_SELF":              5,
	"VIEW_OTHER_USERS_HISTORY": 6,
	"VIEW_OWN_HISTORY":         7,
}

func (Authorization) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_f1516b12a244c06b, []int{0}
}

type SpecialUserID int32

const (
	ROOT      SpecialUserID = 0
	ANONYMOUS SpecialUserID = 1
)

var SpecialUserID_name = map[int32]string{
	0: "ROOT",
	1: "ANONYMOUS",
}

var SpecialUserID_value = map[string]int32{
	"ROOT":      0,
	"ANONYMOUS": 1,
}

func (SpecialUserID) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_f1516b12a244c06b, []int{1}
}

type ID struct {
	Id string `protobuf:"bytes,1,opt,name=id,proto3,embedded=id" json:"id,omitempty"`
}

func (m *ID) Reset()      { *m = ID{} }
func (*ID) ProtoMessage() {}
func (*ID) Descriptor() ([]byte, []int) {
	return fileDescriptor_f1516b12a244c06b, []int{0}
}
func (m *ID) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ID) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ID.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ID) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ID.Merge(m, src)
}
func (m *ID) XXX_Size() int {
	return m.Size()
}
func (m *ID) XXX_DiscardUnknown() {
	xxx_messageInfo_ID.DiscardUnknown(m)
}

var xxx_messageInfo_ID proto.InternalMessageInfo

type UserID struct {
	// Types that are valid to be assigned to ID:
	//	*UserID_SpecialUserID
	//	*UserID_RegularUserID
	ID isUserID_ID `protobuf_oneof:"ID"`
}

func (m *UserID) Reset()      { *m = UserID{} }
func (*UserID) ProtoMessage() {}
func (*UserID) Descriptor() ([]byte, []int) {
	return fileDescriptor_f1516b12a244c06b, []int{1}
}
func (m *UserID) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UserID) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UserID.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UserID) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UserID.Merge(m, src)
}
func (m *UserID) XXX_Size() int {
	return m.Size()
}
func (m *UserID) XXX_DiscardUnknown() {
	xxx_messageInfo_UserID.DiscardUnknown(m)
}

var xxx_messageInfo_UserID proto.InternalMessageInfo

type isUserID_ID interface {
	isUserID_ID()
	Equal(interface{}) bool
	VerboseEqual(interface{}) error
	MarshalTo([]byte) (int, error)
	Size() int
	Compare(interface{}) int
}

type UserID_SpecialUserID struct {
	SpecialUserID SpecialUserID `protobuf:"varint,1,opt,name=specialUserID,proto3,enum=protos.SpecialUserID,oneof"`
}
type UserID_RegularUserID struct {
	RegularUserID *RegularUserID `protobuf:"bytes,2,opt,name=regularUserID,proto3,oneof"`
}

func (*UserID_SpecialUserID) isUserID_ID() {}
func (*UserID_RegularUserID) isUserID_ID() {}

func (m *UserID) GetID() isUserID_ID {
	if m != nil {
		return m.ID
	}
	return nil
}

func (m *UserID) GetSpecialUserID() SpecialUserID {
	if x, ok := m.GetID().(*UserID_SpecialUserID); ok {
		return x.SpecialUserID
	}
	return ROOT
}

func (m *UserID) GetRegularUserID() *RegularUserID {
	if x, ok := m.GetID().(*UserID_RegularUserID); ok {
		return x.RegularUserID
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*UserID) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*UserID_SpecialUserID)(nil),
		(*UserID_RegularUserID)(nil),
	}
}

type HistoryID struct {
	*ID `protobuf:"bytes,1,opt,name=id,proto3,embedded=id" json:"id,omitempty"`
}

func (m *HistoryID) Reset()      { *m = HistoryID{} }
func (*HistoryID) ProtoMessage() {}
func (*HistoryID) Descriptor() ([]byte, []int) {
	return fileDescriptor_f1516b12a244c06b, []int{2}
}
func (m *HistoryID) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HistoryID) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_HistoryID.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *HistoryID) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HistoryID.Merge(m, src)
}
func (m *HistoryID) XXX_Size() int {
	return m.Size()
}
func (m *HistoryID) XXX_DiscardUnknown() {
	xxx_messageInfo_HistoryID.DiscardUnknown(m)
}

var xxx_messageInfo_HistoryID proto.InternalMessageInfo

type RegularUserID struct {
	*ID `protobuf:"bytes,1,opt,name=id,proto3,embedded=id" json:"id,omitempty"`
}

func (m *RegularUserID) Reset()      { *m = RegularUserID{} }
func (*RegularUserID) ProtoMessage() {}
func (*RegularUserID) Descriptor() ([]byte, []int) {
	return fileDescriptor_f1516b12a244c06b, []int{3}
}
func (m *RegularUserID) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RegularUserID) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RegularUserID.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RegularUserID) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RegularUserID.Merge(m, src)
}
func (m *RegularUserID) XXX_Size() int {
	return m.Size()
}
func (m *RegularUserID) XXX_DiscardUnknown() {
	xxx_messageInfo_RegularUserID.DiscardUnknown(m)
}

var xxx_messageInfo_RegularUserID proto.InternalMessageInfo

type OIDCProviderID struct {
	*ID `protobuf:"bytes,1,opt,name=id,proto3,embedded=id" json:"id,omitempty"`
}

func (m *OIDCProviderID) Reset()      { *m = OIDCProviderID{} }
func (*OIDCProviderID) ProtoMessage() {}
func (*OIDCProviderID) Descriptor() ([]byte, []int) {
	return fileDescriptor_f1516b12a244c06b, []int{4}
}
func (m *OIDCProviderID) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OIDCProviderID) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OIDCProviderID.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OIDCProviderID) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OIDCProviderID.Merge(m, src)
}
func (m *OIDCProviderID) XXX_Size() int {
	return m.Size()
}
func (m *OIDCProviderID) XXX_DiscardUnknown() {
	xxx_messageInfo_OIDCProviderID.DiscardUnknown(m)
}

var xxx_messageInfo_OIDCProviderID proto.InternalMessageInfo

type RegularUser struct {
	Id             *UserID         `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	Name           string          `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	Authorizations []Authorization `protobuf:"varint,3,rep,packed,name=authorizations,proto3,enum=protos.Authorization" json:"authorizations,omitempty"`
	HistoryID      []*HistoryID    `protobuf:"bytes,4,rep,name=historyID,proto3" json:"historyID,omitempty"`
}

func (m *RegularUser) Reset()      { *m = RegularUser{} }
func (*RegularUser) ProtoMessage() {}
func (*RegularUser) Descriptor() ([]byte, []int) {
	return fileDescriptor_f1516b12a244c06b, []int{5}
}
func (m *RegularUser) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RegularUser) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RegularUser.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RegularUser) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RegularUser.Merge(m, src)
}
func (m *RegularUser) XXX_Size() int {
	return m.Size()
}
func (m *RegularUser) XXX_DiscardUnknown() {
	xxx_messageInfo_RegularUser.DiscardUnknown(m)
}

var xxx_messageInfo_RegularUser proto.InternalMessageInfo

func (m *RegularUser) GetId() *UserID {
	if m != nil {
		return m.Id
	}
	return nil
}

func (m *RegularUser) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *RegularUser) GetAuthorizations() []Authorization {
	if m != nil {
		return m.Authorizations
	}
	return nil
}

func (m *RegularUser) GetHistoryID() []*HistoryID {
	if m != nil {
		return m.HistoryID
	}
	return nil
}

type SpecialUser struct {
	Id             SpecialUserID   `protobuf:"varint,1,opt,name=id,proto3,enum=protos.SpecialUserID" json:"id,omitempty"`
	Authorizations []Authorization `protobuf:"varint,2,rep,packed,name=authorizations,proto3,enum=protos.Authorization" json:"authorizations,omitempty"`
	HistoryID      []*HistoryID    `protobuf:"bytes,3,rep,name=historyID,proto3" json:"historyID,omitempty"`
}

func (m *SpecialUser) Reset()      { *m = SpecialUser{} }
func (*SpecialUser) ProtoMessage() {}
func (*SpecialUser) Descriptor() ([]byte, []int) {
	return fileDescriptor_f1516b12a244c06b, []int{6}
}
func (m *SpecialUser) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SpecialUser) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SpecialUser.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SpecialUser) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SpecialUser.Merge(m, src)
}
func (m *SpecialUser) XXX_Size() int {
	return m.Size()
}
func (m *SpecialUser) XXX_DiscardUnknown() {
	xxx_messageInfo_SpecialUser.DiscardUnknown(m)
}

var xxx_messageInfo_SpecialUser proto.InternalMessageInfo

func (m *SpecialUser) GetId() SpecialUserID {
	if m != nil {
		return m.Id
	}
	return ROOT
}

func (m *SpecialUser) GetAuthorizations() []Authorization {
	if m != nil {
		return m.Authorizations
	}
	return nil
}

func (m *SpecialUser) GetHistoryID() []*HistoryID {
	if m != nil {
		return m.HistoryID
	}
	return nil
}

type AuthorizationGrant struct {
	From *UserID         `protobuf:"bytes,1,opt,name=from,proto3" json:"from,omitempty"`
	Of   []Authorization `protobuf:"varint,2,rep,packed,name=Of,json=of,proto3,enum=protos.Authorization" json:"Of,omitempty"`
}

func (m *AuthorizationGrant) Reset()      { *m = AuthorizationGrant{} }
func (*AuthorizationGrant) ProtoMessage() {}
func (*AuthorizationGrant) Descriptor() ([]byte, []int) {
	return fileDescriptor_f1516b12a244c06b, []int{7}
}
func (m *AuthorizationGrant) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AuthorizationGrant) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AuthorizationGrant.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AuthorizationGrant) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AuthorizationGrant.Merge(m, src)
}
func (m *AuthorizationGrant) XXX_Size() int {
	return m.Size()
}
func (m *AuthorizationGrant) XXX_DiscardUnknown() {
	xxx_messageInfo_AuthorizationGrant.DiscardUnknown(m)
}

var xxx_messageInfo_AuthorizationGrant proto.InternalMessageInfo

func (m *AuthorizationGrant) GetFrom() *UserID {
	if m != nil {
		return m.From
	}
	return nil
}

func (m *AuthorizationGrant) GetOf() []Authorization {
	if m != nil {
		return m.Of
	}
	return nil
}

type IDToken struct {
	Issuer          string              `protobuf:"bytes,1,opt,name=issuer,proto3" json:"issuer,omitempty"`
	Subject         string              `protobuf:"bytes,2,opt,name=subject,proto3" json:"subject,omitempty"`
	Audicence       string              `protobuf:"bytes,3,opt,name=audicence,proto3" json:"audicence,omitempty"`
	Expiration      *protobuf.Timestamp `protobuf:"bytes,4,opt,name=expiration,proto3" json:"expiration,omitempty"`
	Issued          *protobuf.Timestamp `protobuf:"bytes,5,opt,name=issued,proto3" json:"issued,omitempty"`
	Nonce           string              `protobuf:"bytes,6,opt,name=nonce,proto3" json:"nonce,omitempty"`
	AuthorizedParty string              `protobuf:"bytes,7,opt,name=authorizedParty,proto3" json:"authorizedParty,omitempty"`
}

func (m *IDToken) Reset()      { *m = IDToken{} }
func (*IDToken) ProtoMessage() {}
func (*IDToken) Descriptor() ([]byte, []int) {
	return fileDescriptor_f1516b12a244c06b, []int{8}
}
func (m *IDToken) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IDToken) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_IDToken.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *IDToken) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IDToken.Merge(m, src)
}
func (m *IDToken) XXX_Size() int {
	return m.Size()
}
func (m *IDToken) XXX_DiscardUnknown() {
	xxx_messageInfo_IDToken.DiscardUnknown(m)
}

var xxx_messageInfo_IDToken proto.InternalMessageInfo

func (m *IDToken) GetIssuer() string {
	if m != nil {
		return m.Issuer
	}
	return ""
}

func (m *IDToken) GetSubject() string {
	if m != nil {
		return m.Subject
	}
	return ""
}

func (m *IDToken) GetAudicence() string {
	if m != nil {
		return m.Audicence
	}
	return ""
}

func (m *IDToken) GetExpiration() *protobuf.Timestamp {
	if m != nil {
		return m.Expiration
	}
	return nil
}

func (m *IDToken) GetIssued() *protobuf.Timestamp {
	if m != nil {
		return m.Issued
	}
	return nil
}

func (m *IDToken) GetNonce() string {
	if m != nil {
		return m.Nonce
	}
	return ""
}

func (m *IDToken) GetAuthorizedParty() string {
	if m != nil {
		return m.AuthorizedParty
	}
	return ""
}

type OIDCProvider struct {
	Id                    *OIDCProviderID `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	Name                  string          `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	Callback              string          `protobuf:"bytes,3,opt,name=callback,proto3" json:"callback,omitempty"`
	AuthorizationEndpoint string          `protobuf:"bytes,4,opt,name=authorizationEndpoint,proto3" json:"authorizationEndpoint,omitempty"`
	ClientID              string          `protobuf:"bytes,5,opt,name=clientID,proto3" json:"clientID,omitempty"`
}

func (m *OIDCProvider) Reset()      { *m = OIDCProvider{} }
func (*OIDCProvider) ProtoMessage() {}
func (*OIDCProvider) Descriptor() ([]byte, []int) {
	return fileDescriptor_f1516b12a244c06b, []int{9}
}
func (m *OIDCProvider) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OIDCProvider) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OIDCProvider.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OIDCProvider) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OIDCProvider.Merge(m, src)
}
func (m *OIDCProvider) XXX_Size() int {
	return m.Size()
}
func (m *OIDCProvider) XXX_DiscardUnknown() {
	xxx_messageInfo_OIDCProvider.DiscardUnknown(m)
}

var xxx_messageInfo_OIDCProvider proto.InternalMessageInfo

func (m *OIDCProvider) GetId() *OIDCProviderID {
	if m != nil {
		return m.Id
	}
	return nil
}

func (m *OIDCProvider) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *OIDCProvider) GetCallback() string {
	if m != nil {
		return m.Callback
	}
	return ""
}

func (m *OIDCProvider) GetAuthorizationEndpoint() string {
	if m != nil {
		return m.AuthorizationEndpoint
	}
	return ""
}

func (m *OIDCProvider) GetClientID() string {
	if m != nil {
		return m.ClientID
	}
	return ""
}

func init() {
	proto.RegisterEnum("protos.Authorization", Authorization_name, Authorization_value)
	proto.RegisterEnum("protos.SpecialUserID", SpecialUserID_name, SpecialUserID_value)
	proto.RegisterType((*ID)(nil), "protos.ID")
	proto.RegisterType((*UserID)(nil), "protos.UserID")
	proto.RegisterType((*HistoryID)(nil), "protos.HistoryID")
	proto.RegisterType((*RegularUserID)(nil), "protos.RegularUserID")
	proto.RegisterType((*OIDCProviderID)(nil), "protos.OIDCProviderID")
	proto.RegisterType((*RegularUser)(nil), "protos.RegularUser")
	proto.RegisterType((*SpecialUser)(nil), "protos.SpecialUser")
	proto.RegisterType((*AuthorizationGrant)(nil), "protos.AuthorizationGrant")
	proto.RegisterType((*IDToken)(nil), "protos.IDToken")
	proto.RegisterType((*OIDCProvider)(nil), "protos.OIDCProvider")
}

func init() { proto.RegisterFile("proto/tab.proto", fileDescriptor_f1516b12a244c06b) }

var fileDescriptor_f1516b12a244c06b = []byte{
	// 787 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x9c, 0x55, 0x41, 0x6f, 0xe2, 0x46,
	0x14, 0xf6, 0x18, 0x07, 0x96, 0x47, 0x21, 0xde, 0x11, 0x89, 0x2c, 0xb4, 0x9a, 0x45, 0x48, 0xad,
	0xd0, 0x4a, 0x35, 0x5d, 0x76, 0x4f, 0x95, 0x56, 0x5a, 0xb2, 0x66, 0x8b, 0xa5, 0x24, 0x8e, 0x0c,
	0xec, 0x2a, 0x27, 0x64, 0xc0, 0x10, 0x77, 0xc1, 0x83, 0x6c, 0x13, 0x35, 0x3d, 0xf5, 0x5a, 0xa9,
	0x87, 0xfe, 0x88, 0x1e, 0x72, 0xed, 0x2d, 0x87, 0xfe, 0x80, 0x1e, 0x39, 0xe6, 0x54, 0x05, 0x73,
	0xe9, 0x31, 0x3f, 0xa1, 0xf2, 0xd8, 0x26, 0x76, 0xda, 0xb4, 0x51, 0x4f, 0xcc, 0x7b, 0xdf, 0xf7,
	0xbd, 0xf9, 0x78, 0x6f, 0x9e, 0x0c, 0xbb, 0x0b, 0x87, 0x7a, 0xb4, 0xe1, 0x19, 0x43, 0x99, 0x9d,
	0x70, 0x96, 0xfd, 0xb8, 0x95, 0xd7, 0x53, 0xcb, 0x3b, 0x5b, 0x0e, 0xe5, 0x11, 0x9d, 0x37, 0xa6,
	0x74, 0x4a, 0x1b, 0x2c, 0x3f, 0x5c, 0x4e, 0xde, 0x9e, 0xbf, 0x94, 0x5f, 0xc9, 0x5f, 0xb1, 0x64,
	0x28, 0x0e, 0x4e, 0xa1, 0xba, 0xf2, 0x7c, 0x4a, 0xe9, 0x74, 0x66, 0x6e, 0xc9, 0x0d, 0xcf, 0x9a,
	0x9b, 0xae, 0x67, 0xcc, 0x17, 0x21, 0xa1, 0x56, 0x01, 0x5e, 0x55, 0x70, 0x19, 0x78, 0x6b, 0x2c,
	0xa1, 0x2a, 0xaa, 0xe7, 0x0f, 0x84, 0xd5, 0x1f, 0xcf, 0x91, 0xce, 0x5b, 0xe3, 0xda, 0x4f, 0x08,
	0xb2, 0x7d, 0xd7, 0x74, 0x54, 0x05, 0xbf, 0x81, 0xa2, 0xbb, 0x30, 0x47, 0x96, 0x31, 0x0b, 0x13,
	0x8c, 0x5b, 0x6a, 0xee, 0x85, 0x55, 0x5c, 0xb9, 0x9b, 0x04, 0x3b, 0x9c, 0x9e, 0x66, 0x07, 0x72,
	0xc7, 0x9c, 0x2e, 0x67, 0x86, 0x13, 0xc9, 0xf9, 0x2a, 0xaa, 0x17, 0xee, 0xe4, 0x7a, 0x12, 0x0c,
	0xe4, 0x29, 0xf6, 0x81, 0x10, 0x98, 0xac, 0x7d, 0x09, 0xf9, 0x8e, 0xe5, 0x7a, 0xd4, 0xb9, 0x50,
	0x15, 0x5c, 0xdd, 0x3a, 0x2e, 0x34, 0x21, 0x2e, 0x13, 0x50, 0xb7, 0xee, 0x5f, 0x42, 0x31, 0x55,
	0xf6, 0x11, 0x92, 0x26, 0x94, 0x34, 0x55, 0x79, 0x77, 0xe2, 0xd0, 0x73, 0x6b, 0xfc, 0x48, 0xcd,
	0xaf, 0x08, 0x0a, 0x89, 0x7b, 0x30, 0x49, 0x28, 0x4a, 0xb1, 0x22, 0x74, 0x10, 0xf0, 0x31, 0x06,
	0xc1, 0x36, 0xe6, 0x26, 0xeb, 0x40, 0x5e, 0x67, 0x67, 0xfc, 0x06, 0x4a, 0xc6, 0xd2, 0x3b, 0xa3,
	0x8e, 0xf5, 0xbd, 0xe1, 0x59, 0xd4, 0x76, 0xa5, 0x4c, 0x35, 0x93, 0x6c, 0x6f, 0x2b, 0x89, 0xea,
	0xf7, 0xc8, 0xb8, 0x01, 0xf9, 0xb3, 0xb8, 0x31, 0x92, 0x50, 0xcd, 0xd4, 0x0b, 0xcd, 0xa7, 0xb1,
	0x72, 0xdb, 0x31, 0xfd, 0x8e, 0x53, 0xfb, 0x05, 0x41, 0x21, 0x31, 0x31, 0xfc, 0xf9, 0xd6, 0xf3,
	0x43, 0x23, 0x65, 0xd6, 0xff, 0x6e, 0x93, 0xff, 0xdf, 0x36, 0x33, 0x8f, 0xb0, 0x39, 0x00, 0x9c,
	0xaa, 0xf8, 0x8d, 0x63, 0xd8, 0x1e, 0xae, 0x81, 0x30, 0x71, 0xe8, 0xfc, 0x81, 0x16, 0x33, 0x2c,
	0xf8, 0x43, 0xda, 0xe4, 0xdf, 0xdd, 0xf1, 0x74, 0x52, 0xfb, 0x91, 0x87, 0x9c, 0xaa, 0xf4, 0xe8,
	0x27, 0xd3, 0xc6, 0xfb, 0x90, 0xb5, 0x5c, 0x77, 0x69, 0x3a, 0xe1, 0x1a, 0xe8, 0x51, 0x84, 0x25,
	0xc8, 0xb9, 0xcb, 0xe1, 0xb7, 0xe6, 0xc8, 0x8b, 0x46, 0x16, 0x87, 0xf8, 0x19, 0xe4, 0x8d, 0xe5,
	0xd8, 0x1a, 0x99, 0xf6, 0xc8, 0x94, 0x32, 0x0c, 0xbb, 0x4b, 0xe0, 0xaf, 0x01, 0xcc, 0xef, 0x16,
	0x96, 0xc3, 0x6e, 0x93, 0x04, 0x66, 0xb6, 0x22, 0x87, 0xeb, 0x28, 0xc7, 0xeb, 0x28, 0xf7, 0xe2,
	0x75, 0xd4, 0x13, 0x6c, 0xdc, 0x8c, 0xbc, 0x8c, 0xa5, 0x9d, 0xff, 0xd4, 0x45, 0x4c, 0x5c, 0x86,
	0x1d, 0x9b, 0x06, 0x4e, 0xb2, 0xcc, 0x49, 0x18, 0xe0, 0x3a, 0xec, 0xc6, 0x53, 0x30, 0xc7, 0x27,
	0x86, 0xe3, 0x5d, 0x48, 0x39, 0x86, 0xdf, 0x4f, 0xd7, 0xae, 0x10, 0x7c, 0x96, 0x7c, 0xfc, 0xf8,
	0x8b, 0xc4, 0x43, 0xde, 0x8f, 0x7b, 0x98, 0x5e, 0x8f, 0x07, 0x1f, 0x74, 0x05, 0x9e, 0x8c, 0x8c,
	0xd9, 0x6c, 0x68, 0x8c, 0x3e, 0x45, 0x9d, 0xd9, 0xc6, 0xf8, 0x35, 0xec, 0xa5, 0x1e, 0x46, 0xdb,
	0x1e, 0x2f, 0xa8, 0x65, 0x7b, 0xac, 0x47, 0x79, 0xfd, 0x9f, 0x41, 0x56, 0x71, 0x66, 0x99, 0xb6,
	0xa7, 0x2a, 0xac, 0x29, 0x41, 0xc5, 0x28, 0x7e, 0xf1, 0x1b, 0x82, 0x62, 0x6a, 0xb8, 0xb8, 0x04,
	0xf0, 0x41, 0x6d, 0x7f, 0x1c, 0xf4, 0xbb, 0x6d, 0xbd, 0x2b, 0x72, 0x78, 0x0f, 0x9e, 0x1e, 0x69,
	0x8a, 0xfa, 0xfe, 0x74, 0xf0, 0xa1, 0x75, 0xa8, 0x2a, 0x83, 0x56, 0xbf, 0xd7, 0x11, 0x11, 0x2e,
	0x42, 0xbe, 0xa5, 0x28, 0x03, 0xb5, 0xd7, 0x3e, 0xea, 0x8a, 0x3c, 0xde, 0x07, 0x1c, 0xb1, 0xb4,
	0x5e, 0xa7, 0xad, 0x47, 0xea, 0x0c, 0x96, 0xa0, 0x1c, 0xe5, 0xbb, 0x27, 0xed, 0x77, 0x6a, 0xeb,
	0x30, 0x42, 0x04, 0xbc, 0x0b, 0x85, 0x18, 0x69, 0x1f, 0xbe, 0x17, 0x77, 0xf0, 0x33, 0x90, 0xd8,
	0xc5, 0x89, 0x02, 0x83, 0x8e, 0xda, 0xed, 0x69, 0xfa, 0xa9, 0x98, 0xc5, 0x65, 0x10, 0x43, 0xf4,
	0xe3, 0xf1, 0x36, 0x9b, 0x7b, 0x51, 0x87, 0x62, 0x6a, 0xd7, 0xf0, 0x13, 0x10, 0x74, 0x4d, 0xeb,
	0x89, 0x1c, 0x33, 0x78, 0xac, 0x1d, 0x9f, 0x1e, 0x69, 0xfd, 0xae, 0x88, 0x0e, 0xde, 0xae, 0xd6,
	0x84, 0xbb, 0x5e, 0x13, 0xee, 0x66, 0x4d, 0xd0, 0xed, 0x9a, 0xa0, 0x1f, 0x7c, 0x82, 0x2e, 0x7d,
	0x82, 0xae, 0x7c, 0x82, 0x7e, 0xf7, 0x09, 0x5a, 0xf9, 0x04, 0xdd, 0xf8, 0x04, 0xfd, 0xe9, 0x13,
	0xee, 0xd6, 0x27, 0xe8, 0xe7, 0x0d, 0xe1, 0x2e, 0x37, 0x04, 0xad, 0x36, 0x84, 0xbb, 0xde, 0x10,
	0x6e, 0x18, 0x7e, 0x4d, 0x5e, 0xfd, 0x15, 0x00, 0x00, 0xff, 0xff, 0x93, 0x58, 0xd1, 0xc0, 0x67,
	0x06, 0x00, 0x00,
}

func (this *ID) Compare(that interface{}) int {
	if that == nil {
		if this == nil {
			return 0
		}
		return 1
	}

	that1, ok := that.(*ID)
	if !ok {
		that2, ok := that.(ID)
		if ok {
			that1 = &that2
		} else {
			return 1
		}
	}
	if that1 == nil {
		if this == nil {
			return 0
		}
		return 1
	} else if this == nil {
		return -1
	}
	if this.string != that1.string {
		if this.string < that1.string {
			return -1
		}
		return 1
	}
	return 0
}
func (this *UserID) Compare(that interface{}) int {
	if that == nil {
		if this == nil {
			return 0
		}
		return 1
	}

	that1, ok := that.(*UserID)
	if !ok {
		that2, ok := that.(UserID)
		if ok {
			that1 = &that2
		} else {
			return 1
		}
	}
	if that1 == nil {
		if this == nil {
			return 0
		}
		return 1
	} else if this == nil {
		return -1
	}
	if that1.ID == nil {
		if this.ID != nil {
			return 1
		}
	} else if this.ID == nil {
		return -1
	} else {
		thisType := -1
		switch this.ID.(type) {
		case *UserID_SpecialUserID:
			thisType = 0
		case *UserID_RegularUserID:
			thisType = 1
		default:
			panic(fmt.Sprintf("compare: unexpected type %T in oneof", this.ID))
		}
		that1Type := -1
		switch that1.ID.(type) {
		case *UserID_SpecialUserID:
			that1Type = 0
		case *UserID_RegularUserID:
			that1Type = 1
		default:
			panic(fmt.Sprintf("compare: unexpected type %T in oneof", that1.ID))
		}
		if thisType == that1Type {
			if c := this.ID.Compare(that1.ID); c != 0 {
				return c
			}
		} else if thisType < that1Type {
			return -1
		} else if thisType > that1Type {
			return 1
		}
	}
	return 0
}
func (this *UserID_SpecialUserID) Compare(that interface{}) int {
	if that == nil {
		if this == nil {
			return 0
		}
		return 1
	}

	that1, ok := that.(*UserID_SpecialUserID)
	if !ok {
		that2, ok := that.(UserID_SpecialUserID)
		if ok {
			that1 = &that2
		} else {
			return 1
		}
	}
	if that1 == nil {
		if this == nil {
			return 0
		}
		return 1
	} else if this == nil {
		return -1
	}
	if this.SpecialUserID != that1.SpecialUserID {
		if this.SpecialUserID < that1.SpecialUserID {
			return -1
		}
		return 1
	}
	return 0
}
func (this *UserID_RegularUserID) Compare(that interface{}) int {
	if that == nil {
		if this == nil {
			return 0
		}
		return 1
	}

	that1, ok := that.(*UserID_RegularUserID)
	if !ok {
		that2, ok := that.(UserID_RegularUserID)
		if ok {
			that1 = &that2
		} else {
			return 1
		}
	}
	if that1 == nil {
		if this == nil {
			return 0
		}
		return 1
	} else if this == nil {
		return -1
	}
	if c := this.RegularUserID.Compare(that1.RegularUserID); c != 0 {
		return c
	}
	return 0
}
func (this *HistoryID) Compare(that interface{}) int {
	if that == nil {
		if this == nil {
			return 0
		}
		return 1
	}

	that1, ok := that.(*HistoryID)
	if !ok {
		that2, ok := that.(HistoryID)
		if ok {
			that1 = &that2
		} else {
			return 1
		}
	}
	if that1 == nil {
		if this == nil {
			return 0
		}
		return 1
	} else if this == nil {
		return -1
	}
	if c := this.ID.Compare(that1.ID); c != 0 {
		return c
	}
	return 0
}
func (this *RegularUserID) Compare(that interface{}) int {
	if that == nil {
		if this == nil {
			return 0
		}
		return 1
	}

	that1, ok := that.(*RegularUserID)
	if !ok {
		that2, ok := that.(RegularUserID)
		if ok {
			that1 = &that2
		} else {
			return 1
		}
	}
	if that1 == nil {
		if this == nil {
			return 0
		}
		return 1
	} else if this == nil {
		return -1
	}
	if c := this.ID.Compare(that1.ID); c != 0 {
		return c
	}
	return 0
}
func (this *OIDCProviderID) Compare(that interface{}) int {
	if that == nil {
		if this == nil {
			return 0
		}
		return 1
	}

	that1, ok := that.(*OIDCProviderID)
	if !ok {
		that2, ok := that.(OIDCProviderID)
		if ok {
			that1 = &that2
		} else {
			return 1
		}
	}
	if that1 == nil {
		if this == nil {
			return 0
		}
		return 1
	} else if this == nil {
		return -1
	}
	if c := this.ID.Compare(that1.ID); c != 0 {
		return c
	}
	return 0
}
func (this *RegularUser) Compare(that interface{}) int {
	if that == nil {
		if this == nil {
			return 0
		}
		return 1
	}

	that1, ok := that.(*RegularUser)
	if !ok {
		that2, ok := that.(RegularUser)
		if ok {
			that1 = &that2
		} else {
			return 1
		}
	}
	if that1 == nil {
		if this == nil {
			return 0
		}
		return 1
	} else if this == nil {
		return -1
	}
	if c := this.Id.Compare(that1.Id); c != 0 {
		return c
	}
	if this.Name != that1.Name {
		if this.Name < that1.Name {
			return -1
		}
		return 1
	}
	if len(this.Authorizations) != len(that1.Authorizations) {
		if len(this.Authorizations) < len(that1.Authorizations) {
			return -1
		}
		return 1
	}
	for i := range this.Authorizations {
		if this.Authorizations[i] != that1.Authorizations[i] {
			if this.Authorizations[i] < that1.Authorizations[i] {
				return -1
			}
			return 1
		}
	}
	if len(this.HistoryID) != len(that1.HistoryID) {
		if len(this.HistoryID) < len(that1.HistoryID) {
			return -1
		}
		return 1
	}
	for i := range this.HistoryID {
		if c := this.HistoryID[i].Compare(that1.HistoryID[i]); c != 0 {
			return c
		}
	}
	return 0
}
func (this *SpecialUser) Compare(that interface{}) int {
	if that == nil {
		if this == nil {
			return 0
		}
		return 1
	}

	that1, ok := that.(*SpecialUser)
	if !ok {
		that2, ok := that.(SpecialUser)
		if ok {
			that1 = &that2
		} else {
			return 1
		}
	}
	if that1 == nil {
		if this == nil {
			return 0
		}
		return 1
	} else if this == nil {
		return -1
	}
	if this.Id != that1.Id {
		if this.Id < that1.Id {
			return -1
		}
		return 1
	}
	if len(this.Authorizations) != len(that1.Authorizations) {
		if len(this.Authorizations) < len(that1.Authorizations) {
			return -1
		}
		return 1
	}
	for i := range this.Authorizations {
		if this.Authorizations[i] != that1.Authorizations[i] {
			if this.Authorizations[i] < that1.Authorizations[i] {
				return -1
			}
			return 1
		}
	}
	if len(this.HistoryID) != len(that1.HistoryID) {
		if len(this.HistoryID) < len(that1.HistoryID) {
			return -1
		}
		return 1
	}
	for i := range this.HistoryID {
		if c := this.HistoryID[i].Compare(that1.HistoryID[i]); c != 0 {
			return c
		}
	}
	return 0
}
func (this *AuthorizationGrant) Compare(that interface{}) int {
	if that == nil {
		if this == nil {
			return 0
		}
		return 1
	}

	that1, ok := that.(*AuthorizationGrant)
	if !ok {
		that2, ok := that.(AuthorizationGrant)
		if ok {
			that1 = &that2
		} else {
			return 1
		}
	}
	if that1 == nil {
		if this == nil {
			return 0
		}
		return 1
	} else if this == nil {
		return -1
	}
	if c := this.From.Compare(that1.From); c != 0 {
		return c
	}
	if len(this.Of) != len(that1.Of) {
		if len(this.Of) < len(that1.Of) {
			return -1
		}
		return 1
	}
	for i := range this.Of {
		if this.Of[i] != that1.Of[i] {
			if this.Of[i] < that1.Of[i] {
				return -1
			}
			return 1
		}
	}
	return 0
}
func (this *IDToken) Compare(that interface{}) int {
	if that == nil {
		if this == nil {
			return 0
		}
		return 1
	}

	that1, ok := that.(*IDToken)
	if !ok {
		that2, ok := that.(IDToken)
		if ok {
			that1 = &that2
		} else {
			return 1
		}
	}
	if that1 == nil {
		if this == nil {
			return 0
		}
		return 1
	} else if this == nil {
		return -1
	}
	if this.Issuer != that1.Issuer {
		if this.Issuer < that1.Issuer {
			return -1
		}
		return 1
	}
	if this.Subject != that1.Subject {
		if this.Subject < that1.Subject {
			return -1
		}
		return 1
	}
	if this.Audicence != that1.Audicence {
		if this.Audicence < that1.Audicence {
			return -1
		}
		return 1
	}
	if c := this.Expiration.Compare(that1.Expiration); c != 0 {
		return c
	}
	if c := this.Issued.Compare(that1.Issued); c != 0 {
		return c
	}
	if this.Nonce != that1.Nonce {
		if this.Nonce < that1.Nonce {
			return -1
		}
		return 1
	}
	if this.AuthorizedParty != that1.AuthorizedParty {
		if this.AuthorizedParty < that1.AuthorizedParty {
			return -1
		}
		return 1
	}
	return 0
}
func (this *OIDCProvider) Compare(that interface{}) int {
	if that == nil {
		if this == nil {
			return 0
		}
		return 1
	}

	that1, ok := that.(*OIDCProvider)
	if !ok {
		that2, ok := that.(OIDCProvider)
		if ok {
			that1 = &that2
		} else {
			return 1
		}
	}
	if that1 == nil {
		if this == nil {
			return 0
		}
		return 1
	} else if this == nil {
		return -1
	}
	if c := this.Id.Compare(that1.Id); c != 0 {
		return c
	}
	if this.Name != that1.Name {
		if this.Name < that1.Name {
			return -1
		}
		return 1
	}
	if this.Callback != that1.Callback {
		if this.Callback < that1.Callback {
			return -1
		}
		return 1
	}
	if this.AuthorizationEndpoint != that1.AuthorizationEndpoint {
		if this.AuthorizationEndpoint < that1.AuthorizationEndpoint {
			return -1
		}
		return 1
	}
	if this.ClientID != that1.ClientID {
		if this.ClientID < that1.ClientID {
			return -1
		}
		return 1
	}
	return 0
}
func (x Authorization) String() string {
	s, ok := Authorization_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x SpecialUserID) String() string {
	s, ok := SpecialUserID_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (this *ID) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*ID)
	if !ok {
		that2, ok := that.(ID)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *ID")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *ID but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *ID but is not nil && this == nil")
	}
	if this.string != that1.string {
		return fmt.Errorf("string this(%v) Not Equal that(%v)", this.string, that1.string)
	}
	return nil
}
func (this *ID) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ID)
	if !ok {
		that2, ok := that.(ID)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.string != that1.string {
		return false
	}
	return true
}
func (this *UserID) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*UserID)
	if !ok {
		that2, ok := that.(UserID)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *UserID")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *UserID but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *UserID but is not nil && this == nil")
	}
	if that1.ID == nil {
		if this.ID != nil {
			return fmt.Errorf("this.ID != nil && that1.ID == nil")
		}
	} else if this.ID == nil {
		return fmt.Errorf("this.ID == nil && that1.ID != nil")
	} else if err := this.ID.VerboseEqual(that1.ID); err != nil {
		return err
	}
	return nil
}
func (this *UserID_SpecialUserID) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*UserID_SpecialUserID)
	if !ok {
		that2, ok := that.(UserID_SpecialUserID)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *UserID_SpecialUserID")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *UserID_SpecialUserID but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *UserID_SpecialUserID but is not nil && this == nil")
	}
	if this.SpecialUserID != that1.SpecialUserID {
		return fmt.Errorf("SpecialUserID this(%v) Not Equal that(%v)", this.SpecialUserID, that1.SpecialUserID)
	}
	return nil
}
func (this *UserID_RegularUserID) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*UserID_RegularUserID)
	if !ok {
		that2, ok := that.(UserID_RegularUserID)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *UserID_RegularUserID")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *UserID_RegularUserID but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *UserID_RegularUserID but is not nil && this == nil")
	}
	if !this.RegularUserID.Equal(that1.RegularUserID) {
		return fmt.Errorf("RegularUserID this(%v) Not Equal that(%v)", this.RegularUserID, that1.RegularUserID)
	}
	return nil
}
func (this *UserID) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*UserID)
	if !ok {
		that2, ok := that.(UserID)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.ID == nil {
		if this.ID != nil {
			return false
		}
	} else if this.ID == nil {
		return false
	} else if !this.ID.Equal(that1.ID) {
		return false
	}
	return true
}
func (this *UserID_SpecialUserID) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*UserID_SpecialUserID)
	if !ok {
		that2, ok := that.(UserID_SpecialUserID)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.SpecialUserID != that1.SpecialUserID {
		return false
	}
	return true
}
func (this *UserID_RegularUserID) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*UserID_RegularUserID)
	if !ok {
		that2, ok := that.(UserID_RegularUserID)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.RegularUserID.Equal(that1.RegularUserID) {
		return false
	}
	return true
}
func (this *HistoryID) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*HistoryID)
	if !ok {
		that2, ok := that.(HistoryID)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *HistoryID")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *HistoryID but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *HistoryID but is not nil && this == nil")
	}
	if !this.ID.Equal(that1.ID) {
		return fmt.Errorf("ID this(%v) Not Equal that(%v)", this.ID, that1.ID)
	}
	return nil
}
func (this *HistoryID) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*HistoryID)
	if !ok {
		that2, ok := that.(HistoryID)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.ID.Equal(that1.ID) {
		return false
	}
	return true
}
func (this *RegularUserID) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*RegularUserID)
	if !ok {
		that2, ok := that.(RegularUserID)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *RegularUserID")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *RegularUserID but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *RegularUserID but is not nil && this == nil")
	}
	if !this.ID.Equal(that1.ID) {
		return fmt.Errorf("ID this(%v) Not Equal that(%v)", this.ID, that1.ID)
	}
	return nil
}
func (this *RegularUserID) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RegularUserID)
	if !ok {
		that2, ok := that.(RegularUserID)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.ID.Equal(that1.ID) {
		return false
	}
	return true
}
func (this *OIDCProviderID) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*OIDCProviderID)
	if !ok {
		that2, ok := that.(OIDCProviderID)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *OIDCProviderID")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *OIDCProviderID but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *OIDCProviderID but is not nil && this == nil")
	}
	if !this.ID.Equal(that1.ID) {
		return fmt.Errorf("ID this(%v) Not Equal that(%v)", this.ID, that1.ID)
	}
	return nil
}
func (this *OIDCProviderID) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*OIDCProviderID)
	if !ok {
		that2, ok := that.(OIDCProviderID)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.ID.Equal(that1.ID) {
		return false
	}
	return true
}
func (this *RegularUser) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*RegularUser)
	if !ok {
		that2, ok := that.(RegularUser)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *RegularUser")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *RegularUser but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *RegularUser but is not nil && this == nil")
	}
	if !this.Id.Equal(that1.Id) {
		return fmt.Errorf("Id this(%v) Not Equal that(%v)", this.Id, that1.Id)
	}
	if this.Name != that1.Name {
		return fmt.Errorf("Name this(%v) Not Equal that(%v)", this.Name, that1.Name)
	}
	if len(this.Authorizations) != len(that1.Authorizations) {
		return fmt.Errorf("Authorizations this(%v) Not Equal that(%v)", len(this.Authorizations), len(that1.Authorizations))
	}
	for i := range this.Authorizations {
		if this.Authorizations[i] != that1.Authorizations[i] {
			return fmt.Errorf("Authorizations this[%v](%v) Not Equal that[%v](%v)", i, this.Authorizations[i], i, that1.Authorizations[i])
		}
	}
	if len(this.HistoryID) != len(that1.HistoryID) {
		return fmt.Errorf("HistoryID this(%v) Not Equal that(%v)", len(this.HistoryID), len(that1.HistoryID))
	}
	for i := range this.HistoryID {
		if !this.HistoryID[i].Equal(that1.HistoryID[i]) {
			return fmt.Errorf("HistoryID this[%v](%v) Not Equal that[%v](%v)", i, this.HistoryID[i], i, that1.HistoryID[i])
		}
	}
	return nil
}
func (this *RegularUser) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RegularUser)
	if !ok {
		that2, ok := that.(RegularUser)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Id.Equal(that1.Id) {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if len(this.Authorizations) != len(that1.Authorizations) {
		return false
	}
	for i := range this.Authorizations {
		if this.Authorizations[i] != that1.Authorizations[i] {
			return false
		}
	}
	if len(this.HistoryID) != len(that1.HistoryID) {
		return false
	}
	for i := range this.HistoryID {
		if !this.HistoryID[i].Equal(that1.HistoryID[i]) {
			return false
		}
	}
	return true
}
func (this *SpecialUser) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*SpecialUser)
	if !ok {
		that2, ok := that.(SpecialUser)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *SpecialUser")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *SpecialUser but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *SpecialUser but is not nil && this == nil")
	}
	if this.Id != that1.Id {
		return fmt.Errorf("Id this(%v) Not Equal that(%v)", this.Id, that1.Id)
	}
	if len(this.Authorizations) != len(that1.Authorizations) {
		return fmt.Errorf("Authorizations this(%v) Not Equal that(%v)", len(this.Authorizations), len(that1.Authorizations))
	}
	for i := range this.Authorizations {
		if this.Authorizations[i] != that1.Authorizations[i] {
			return fmt.Errorf("Authorizations this[%v](%v) Not Equal that[%v](%v)", i, this.Authorizations[i], i, that1.Authorizations[i])
		}
	}
	if len(this.HistoryID) != len(that1.HistoryID) {
		return fmt.Errorf("HistoryID this(%v) Not Equal that(%v)", len(this.HistoryID), len(that1.HistoryID))
	}
	for i := range this.HistoryID {
		if !this.HistoryID[i].Equal(that1.HistoryID[i]) {
			return fmt.Errorf("HistoryID this[%v](%v) Not Equal that[%v](%v)", i, this.HistoryID[i], i, that1.HistoryID[i])
		}
	}
	return nil
}
func (this *SpecialUser) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SpecialUser)
	if !ok {
		that2, ok := that.(SpecialUser)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Id != that1.Id {
		return false
	}
	if len(this.Authorizations) != len(that1.Authorizations) {
		return false
	}
	for i := range this.Authorizations {
		if this.Authorizations[i] != that1.Authorizations[i] {
			return false
		}
	}
	if len(this.HistoryID) != len(that1.HistoryID) {
		return false
	}
	for i := range this.HistoryID {
		if !this.HistoryID[i].Equal(that1.HistoryID[i]) {
			return false
		}
	}
	return true
}
func (this *AuthorizationGrant) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*AuthorizationGrant)
	if !ok {
		that2, ok := that.(AuthorizationGrant)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *AuthorizationGrant")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *AuthorizationGrant but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *AuthorizationGrant but is not nil && this == nil")
	}
	if !this.From.Equal(that1.From) {
		return fmt.Errorf("From this(%v) Not Equal that(%v)", this.From, that1.From)
	}
	if len(this.Of) != len(that1.Of) {
		return fmt.Errorf("Of this(%v) Not Equal that(%v)", len(this.Of), len(that1.Of))
	}
	for i := range this.Of {
		if this.Of[i] != that1.Of[i] {
			return fmt.Errorf("Of this[%v](%v) Not Equal that[%v](%v)", i, this.Of[i], i, that1.Of[i])
		}
	}
	return nil
}
func (this *AuthorizationGrant) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AuthorizationGrant)
	if !ok {
		that2, ok := that.(AuthorizationGrant)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.From.Equal(that1.From) {
		return false
	}
	if len(this.Of) != len(that1.Of) {
		return false
	}
	for i := range this.Of {
		if this.Of[i] != that1.Of[i] {
			return false
		}
	}
	return true
}
func (this *IDToken) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*IDToken)
	if !ok {
		that2, ok := that.(IDToken)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *IDToken")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *IDToken but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *IDToken but is not nil && this == nil")
	}
	if this.Issuer != that1.Issuer {
		return fmt.Errorf("Issuer this(%v) Not Equal that(%v)", this.Issuer, that1.Issuer)
	}
	if this.Subject != that1.Subject {
		return fmt.Errorf("Subject this(%v) Not Equal that(%v)", this.Subject, that1.Subject)
	}
	if this.Audicence != that1.Audicence {
		return fmt.Errorf("Audicence this(%v) Not Equal that(%v)", this.Audicence, that1.Audicence)
	}
	if !this.Expiration.Equal(that1.Expiration) {
		return fmt.Errorf("Expiration this(%v) Not Equal that(%v)", this.Expiration, that1.Expiration)
	}
	if !this.Issued.Equal(that1.Issued) {
		return fmt.Errorf("Issued this(%v) Not Equal that(%v)", this.Issued, that1.Issued)
	}
	if this.Nonce != that1.Nonce {
		return fmt.Errorf("Nonce this(%v) Not Equal that(%v)", this.Nonce, that1.Nonce)
	}
	if this.AuthorizedParty != that1.AuthorizedParty {
		return fmt.Errorf("AuthorizedParty this(%v) Not Equal that(%v)", this.AuthorizedParty, that1.AuthorizedParty)
	}
	return nil
}
func (this *IDToken) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*IDToken)
	if !ok {
		that2, ok := that.(IDToken)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Issuer != that1.Issuer {
		return false
	}
	if this.Subject != that1.Subject {
		return false
	}
	if this.Audicence != that1.Audicence {
		return false
	}
	if !this.Expiration.Equal(that1.Expiration) {
		return false
	}
	if !this.Issued.Equal(that1.Issued) {
		return false
	}
	if this.Nonce != that1.Nonce {
		return false
	}
	if this.AuthorizedParty != that1.AuthorizedParty {
		return false
	}
	return true
}
func (this *OIDCProvider) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*OIDCProvider)
	if !ok {
		that2, ok := that.(OIDCProvider)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *OIDCProvider")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *OIDCProvider but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *OIDCProvider but is not nil && this == nil")
	}
	if !this.Id.Equal(that1.Id) {
		return fmt.Errorf("Id this(%v) Not Equal that(%v)", this.Id, that1.Id)
	}
	if this.Name != that1.Name {
		return fmt.Errorf("Name this(%v) Not Equal that(%v)", this.Name, that1.Name)
	}
	if this.Callback != that1.Callback {
		return fmt.Errorf("Callback this(%v) Not Equal that(%v)", this.Callback, that1.Callback)
	}
	if this.AuthorizationEndpoint != that1.AuthorizationEndpoint {
		return fmt.Errorf("AuthorizationEndpoint this(%v) Not Equal that(%v)", this.AuthorizationEndpoint, that1.AuthorizationEndpoint)
	}
	if this.ClientID != that1.ClientID {
		return fmt.Errorf("ClientID this(%v) Not Equal that(%v)", this.ClientID, that1.ClientID)
	}
	return nil
}
func (this *OIDCProvider) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*OIDCProvider)
	if !ok {
		that2, ok := that.(OIDCProvider)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Id.Equal(that1.Id) {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if this.Callback != that1.Callback {
		return false
	}
	if this.AuthorizationEndpoint != that1.AuthorizationEndpoint {
		return false
	}
	if this.ClientID != that1.ClientID {
		return false
	}
	return true
}
func (this *ID) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&protos.ID{")
	s = append(s, "string: "+fmt.Sprintf("%#v", this.string)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *UserID) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&protos.UserID{")
	if this.ID != nil {
		s = append(s, "ID: "+fmt.Sprintf("%#v", this.ID)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *UserID_SpecialUserID) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&protos.UserID_SpecialUserID{` +
		`SpecialUserID:` + fmt.Sprintf("%#v", this.SpecialUserID) + `}`}, ", ")
	return s
}
func (this *UserID_RegularUserID) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&protos.UserID_RegularUserID{` +
		`RegularUserID:` + fmt.Sprintf("%#v", this.RegularUserID) + `}`}, ", ")
	return s
}
func (this *HistoryID) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&protos.HistoryID{")
	if this.ID != nil {
		s = append(s, "ID: "+fmt.Sprintf("%#v", this.ID)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *RegularUserID) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&protos.RegularUserID{")
	if this.ID != nil {
		s = append(s, "ID: "+fmt.Sprintf("%#v", this.ID)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *OIDCProviderID) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&protos.OIDCProviderID{")
	if this.ID != nil {
		s = append(s, "ID: "+fmt.Sprintf("%#v", this.ID)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *RegularUser) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&protos.RegularUser{")
	if this.Id != nil {
		s = append(s, "Id: "+fmt.Sprintf("%#v", this.Id)+",\n")
	}
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	s = append(s, "Authorizations: "+fmt.Sprintf("%#v", this.Authorizations)+",\n")
	if this.HistoryID != nil {
		s = append(s, "HistoryID: "+fmt.Sprintf("%#v", this.HistoryID)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *SpecialUser) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&protos.SpecialUser{")
	s = append(s, "Id: "+fmt.Sprintf("%#v", this.Id)+",\n")
	s = append(s, "Authorizations: "+fmt.Sprintf("%#v", this.Authorizations)+",\n")
	if this.HistoryID != nil {
		s = append(s, "HistoryID: "+fmt.Sprintf("%#v", this.HistoryID)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *AuthorizationGrant) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&protos.AuthorizationGrant{")
	if this.From != nil {
		s = append(s, "From: "+fmt.Sprintf("%#v", this.From)+",\n")
	}
	s = append(s, "Of: "+fmt.Sprintf("%#v", this.Of)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *IDToken) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 11)
	s = append(s, "&protos.IDToken{")
	s = append(s, "Issuer: "+fmt.Sprintf("%#v", this.Issuer)+",\n")
	s = append(s, "Subject: "+fmt.Sprintf("%#v", this.Subject)+",\n")
	s = append(s, "Audicence: "+fmt.Sprintf("%#v", this.Audicence)+",\n")
	if this.Expiration != nil {
		s = append(s, "Expiration: "+fmt.Sprintf("%#v", this.Expiration)+",\n")
	}
	if this.Issued != nil {
		s = append(s, "Issued: "+fmt.Sprintf("%#v", this.Issued)+",\n")
	}
	s = append(s, "Nonce: "+fmt.Sprintf("%#v", this.Nonce)+",\n")
	s = append(s, "AuthorizedParty: "+fmt.Sprintf("%#v", this.AuthorizedParty)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *OIDCProvider) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&protos.OIDCProvider{")
	if this.Id != nil {
		s = append(s, "Id: "+fmt.Sprintf("%#v", this.Id)+",\n")
	}
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	s = append(s, "Callback: "+fmt.Sprintf("%#v", this.Callback)+",\n")
	s = append(s, "AuthorizationEndpoint: "+fmt.Sprintf("%#v", this.AuthorizationEndpoint)+",\n")
	s = append(s, "ClientID: "+fmt.Sprintf("%#v", this.ClientID)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func valueToGoStringTab(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}
func (m *ID) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ID) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ID) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.string) > 0 {
		i -= len(m.string)
		copy(dAtA[i:], m.string)
		i = encodeVarintTab(dAtA, i, uint64(len(m.string)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *UserID) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UserID) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UserID) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ID != nil {
		{
			size := m.ID.Size()
			i -= size
			if _, err := m.ID.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *UserID_SpecialUserID) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *UserID_SpecialUserID) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i = encodeVarintTab(dAtA, i, uint64(m.SpecialUserID))
	i--
	dAtA[i] = 0x8
	return len(dAtA) - i, nil
}
func (m *UserID_RegularUserID) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *UserID_RegularUserID) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.RegularUserID != nil {
		{
			size, err := m.RegularUserID.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTab(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *HistoryID) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HistoryID) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HistoryID) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ID != nil {
		{
			size, err := m.ID.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTab(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RegularUserID) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RegularUserID) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RegularUserID) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ID != nil {
		{
			size, err := m.ID.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTab(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *OIDCProviderID) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OIDCProviderID) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OIDCProviderID) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ID != nil {
		{
			size, err := m.ID.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTab(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RegularUser) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RegularUser) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RegularUser) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.HistoryID) > 0 {
		for iNdEx := len(m.HistoryID) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.HistoryID[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTab(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.Authorizations) > 0 {
		dAtA6 := make([]byte, len(m.Authorizations)*10)
		var j5 int
		for _, num := range m.Authorizations {
			for num >= 1<<7 {
				dAtA6[j5] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j5++
			}
			dAtA6[j5] = uint8(num)
			j5++
		}
		i -= j5
		copy(dAtA[i:], dAtA6[:j5])
		i = encodeVarintTab(dAtA, i, uint64(j5))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintTab(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if m.Id != nil {
		{
			size, err := m.Id.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTab(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SpecialUser) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SpecialUser) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SpecialUser) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.HistoryID) > 0 {
		for iNdEx := len(m.HistoryID) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.HistoryID[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTab(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Authorizations) > 0 {
		dAtA9 := make([]byte, len(m.Authorizations)*10)
		var j8 int
		for _, num := range m.Authorizations {
			for num >= 1<<7 {
				dAtA9[j8] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j8++
			}
			dAtA9[j8] = uint8(num)
			j8++
		}
		i -= j8
		copy(dAtA[i:], dAtA9[:j8])
		i = encodeVarintTab(dAtA, i, uint64(j8))
		i--
		dAtA[i] = 0x12
	}
	if m.Id != 0 {
		i = encodeVarintTab(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *AuthorizationGrant) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AuthorizationGrant) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AuthorizationGrant) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Of) > 0 {
		dAtA11 := make([]byte, len(m.Of)*10)
		var j10 int
		for _, num := range m.Of {
			for num >= 1<<7 {
				dAtA11[j10] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j10++
			}
			dAtA11[j10] = uint8(num)
			j10++
		}
		i -= j10
		copy(dAtA[i:], dAtA11[:j10])
		i = encodeVarintTab(dAtA, i, uint64(j10))
		i--
		dAtA[i] = 0x12
	}
	if m.From != nil {
		{
			size, err := m.From.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTab(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *IDToken) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IDToken) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IDToken) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.AuthorizedParty) > 0 {
		i -= len(m.AuthorizedParty)
		copy(dAtA[i:], m.AuthorizedParty)
		i = encodeVarintTab(dAtA, i, uint64(len(m.AuthorizedParty)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.Nonce) > 0 {
		i -= len(m.Nonce)
		copy(dAtA[i:], m.Nonce)
		i = encodeVarintTab(dAtA, i, uint64(len(m.Nonce)))
		i--
		dAtA[i] = 0x32
	}
	if m.Issued != nil {
		{
			size, err := m.Issued.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTab(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.Expiration != nil {
		{
			size, err := m.Expiration.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTab(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if len(m.Audicence) > 0 {
		i -= len(m.Audicence)
		copy(dAtA[i:], m.Audicence)
		i = encodeVarintTab(dAtA, i, uint64(len(m.Audicence)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Subject) > 0 {
		i -= len(m.Subject)
		copy(dAtA[i:], m.Subject)
		i = encodeVarintTab(dAtA, i, uint64(len(m.Subject)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Issuer) > 0 {
		i -= len(m.Issuer)
		copy(dAtA[i:], m.Issuer)
		i = encodeVarintTab(dAtA, i, uint64(len(m.Issuer)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *OIDCProvider) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OIDCProvider) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OIDCProvider) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ClientID) > 0 {
		i -= len(m.ClientID)
		copy(dAtA[i:], m.ClientID)
		i = encodeVarintTab(dAtA, i, uint64(len(m.ClientID)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.AuthorizationEndpoint) > 0 {
		i -= len(m.AuthorizationEndpoint)
		copy(dAtA[i:], m.AuthorizationEndpoint)
		i = encodeVarintTab(dAtA, i, uint64(len(m.AuthorizationEndpoint)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Callback) > 0 {
		i -= len(m.Callback)
		copy(dAtA[i:], m.Callback)
		i = encodeVarintTab(dAtA, i, uint64(len(m.Callback)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintTab(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if m.Id != nil {
		{
			size, err := m.Id.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTab(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintTab(dAtA []byte, offset int, v uint64) int {
	offset -= sovTab(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *ID) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.string)
	if l > 0 {
		n += 1 + l + sovTab(uint64(l))
	}
	return n
}

func (m *UserID) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ID != nil {
		n += m.ID.Size()
	}
	return n
}

func (m *UserID_SpecialUserID) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovTab(uint64(m.SpecialUserID))
	return n
}
func (m *UserID_RegularUserID) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RegularUserID != nil {
		l = m.RegularUserID.Size()
		n += 1 + l + sovTab(uint64(l))
	}
	return n
}
func (m *HistoryID) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ID != nil {
		l = m.ID.Size()
		n += 1 + l + sovTab(uint64(l))
	}
	return n
}

func (m *RegularUserID) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ID != nil {
		l = m.ID.Size()
		n += 1 + l + sovTab(uint64(l))
	}
	return n
}

func (m *OIDCProviderID) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ID != nil {
		l = m.ID.Size()
		n += 1 + l + sovTab(uint64(l))
	}
	return n
}

func (m *RegularUser) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != nil {
		l = m.Id.Size()
		n += 1 + l + sovTab(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovTab(uint64(l))
	}
	if len(m.Authorizations) > 0 {
		l = 0
		for _, e := range m.Authorizations {
			l += sovTab(uint64(e))
		}
		n += 1 + sovTab(uint64(l)) + l
	}
	if len(m.HistoryID) > 0 {
		for _, e := range m.HistoryID {
			l = e.Size()
			n += 1 + l + sovTab(uint64(l))
		}
	}
	return n
}

func (m *SpecialUser) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovTab(uint64(m.Id))
	}
	if len(m.Authorizations) > 0 {
		l = 0
		for _, e := range m.Authorizations {
			l += sovTab(uint64(e))
		}
		n += 1 + sovTab(uint64(l)) + l
	}
	if len(m.HistoryID) > 0 {
		for _, e := range m.HistoryID {
			l = e.Size()
			n += 1 + l + sovTab(uint64(l))
		}
	}
	return n
}

func (m *AuthorizationGrant) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.From != nil {
		l = m.From.Size()
		n += 1 + l + sovTab(uint64(l))
	}
	if len(m.Of) > 0 {
		l = 0
		for _, e := range m.Of {
			l += sovTab(uint64(e))
		}
		n += 1 + sovTab(uint64(l)) + l
	}
	return n
}

func (m *IDToken) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Issuer)
	if l > 0 {
		n += 1 + l + sovTab(uint64(l))
	}
	l = len(m.Subject)
	if l > 0 {
		n += 1 + l + sovTab(uint64(l))
	}
	l = len(m.Audicence)
	if l > 0 {
		n += 1 + l + sovTab(uint64(l))
	}
	if m.Expiration != nil {
		l = m.Expiration.Size()
		n += 1 + l + sovTab(uint64(l))
	}
	if m.Issued != nil {
		l = m.Issued.Size()
		n += 1 + l + sovTab(uint64(l))
	}
	l = len(m.Nonce)
	if l > 0 {
		n += 1 + l + sovTab(uint64(l))
	}
	l = len(m.AuthorizedParty)
	if l > 0 {
		n += 1 + l + sovTab(uint64(l))
	}
	return n
}

func (m *OIDCProvider) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != nil {
		l = m.Id.Size()
		n += 1 + l + sovTab(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovTab(uint64(l))
	}
	l = len(m.Callback)
	if l > 0 {
		n += 1 + l + sovTab(uint64(l))
	}
	l = len(m.AuthorizationEndpoint)
	if l > 0 {
		n += 1 + l + sovTab(uint64(l))
	}
	l = len(m.ClientID)
	if l > 0 {
		n += 1 + l + sovTab(uint64(l))
	}
	return n
}

func sovTab(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozTab(x uint64) (n int) {
	return sovTab(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *ID) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ID{`,
		`string:` + fmt.Sprintf("%v", this.string) + `,`,
		`}`,
	}, "")
	return s
}
func (this *UserID) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&UserID{`,
		`ID:` + fmt.Sprintf("%v", this.ID) + `,`,
		`}`,
	}, "")
	return s
}
func (this *UserID_SpecialUserID) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&UserID_SpecialUserID{`,
		`SpecialUserID:` + fmt.Sprintf("%v", this.SpecialUserID) + `,`,
		`}`,
	}, "")
	return s
}
func (this *UserID_RegularUserID) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&UserID_RegularUserID{`,
		`RegularUserID:` + strings.Replace(fmt.Sprintf("%v", this.RegularUserID), "RegularUserID", "RegularUserID", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *HistoryID) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&HistoryID{`,
		`ID:` + strings.Replace(this.ID.String(), "ID", "ID", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *RegularUserID) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&RegularUserID{`,
		`ID:` + strings.Replace(this.ID.String(), "ID", "ID", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *OIDCProviderID) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&OIDCProviderID{`,
		`ID:` + strings.Replace(this.ID.String(), "ID", "ID", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *RegularUser) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForHistoryID := "[]*HistoryID{"
	for _, f := range this.HistoryID {
		repeatedStringForHistoryID += strings.Replace(f.String(), "HistoryID", "HistoryID", 1) + ","
	}
	repeatedStringForHistoryID += "}"
	s := strings.Join([]string{`&RegularUser{`,
		`Id:` + strings.Replace(this.Id.String(), "UserID", "UserID", 1) + `,`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`Authorizations:` + fmt.Sprintf("%v", this.Authorizations) + `,`,
		`HistoryID:` + repeatedStringForHistoryID + `,`,
		`}`,
	}, "")
	return s
}
func (this *SpecialUser) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForHistoryID := "[]*HistoryID{"
	for _, f := range this.HistoryID {
		repeatedStringForHistoryID += strings.Replace(f.String(), "HistoryID", "HistoryID", 1) + ","
	}
	repeatedStringForHistoryID += "}"
	s := strings.Join([]string{`&SpecialUser{`,
		`Id:` + fmt.Sprintf("%v", this.Id) + `,`,
		`Authorizations:` + fmt.Sprintf("%v", this.Authorizations) + `,`,
		`HistoryID:` + repeatedStringForHistoryID + `,`,
		`}`,
	}, "")
	return s
}
func (this *AuthorizationGrant) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AuthorizationGrant{`,
		`From:` + strings.Replace(this.From.String(), "UserID", "UserID", 1) + `,`,
		`Of:` + fmt.Sprintf("%v", this.Of) + `,`,
		`}`,
	}, "")
	return s
}
func (this *IDToken) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&IDToken{`,
		`Issuer:` + fmt.Sprintf("%v", this.Issuer) + `,`,
		`Subject:` + fmt.Sprintf("%v", this.Subject) + `,`,
		`Audicence:` + fmt.Sprintf("%v", this.Audicence) + `,`,
		`Expiration:` + strings.Replace(fmt.Sprintf("%v", this.Expiration), "Timestamp", "protobuf.Timestamp", 1) + `,`,
		`Issued:` + strings.Replace(fmt.Sprintf("%v", this.Issued), "Timestamp", "protobuf.Timestamp", 1) + `,`,
		`Nonce:` + fmt.Sprintf("%v", this.Nonce) + `,`,
		`AuthorizedParty:` + fmt.Sprintf("%v", this.AuthorizedParty) + `,`,
		`}`,
	}, "")
	return s
}
func (this *OIDCProvider) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&OIDCProvider{`,
		`Id:` + strings.Replace(this.Id.String(), "OIDCProviderID", "OIDCProviderID", 1) + `,`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`Callback:` + fmt.Sprintf("%v", this.Callback) + `,`,
		`AuthorizationEndpoint:` + fmt.Sprintf("%v", this.AuthorizationEndpoint) + `,`,
		`ClientID:` + fmt.Sprintf("%v", this.ClientID) + `,`,
		`}`,
	}, "")
	return s
}
func valueToStringTab(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *ID) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTab
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ID: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ID: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field string", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTab
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTab
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTab
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.string = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTab(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTab
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTab
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UserID) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTab
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UserID: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UserID: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SpecialUserID", wireType)
			}
			var v SpecialUserID
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTab
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= SpecialUserID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ID = &UserID_SpecialUserID{v}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RegularUserID", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTab
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTab
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTab
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &RegularUserID{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ID = &UserID_RegularUserID{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTab(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTab
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTab
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HistoryID) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTab
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HistoryID: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HistoryID: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTab
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTab
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTab
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ID == nil {
				m.ID = &ID{}
			}
			if err := m.ID.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTab(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTab
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTab
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RegularUserID) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTab
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RegularUserID: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RegularUserID: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTab
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTab
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTab
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ID == nil {
				m.ID = &ID{}
			}
			if err := m.ID.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTab(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTab
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTab
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OIDCProviderID) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTab
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OIDCProviderID: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OIDCProviderID: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTab
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTab
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTab
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ID == nil {
				m.ID = &ID{}
			}
			if err := m.ID.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTab(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTab
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTab
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RegularUser) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTab
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RegularUser: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RegularUser: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTab
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTab
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTab
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Id == nil {
				m.Id = &UserID{}
			}
			if err := m.Id.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTab
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTab
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTab
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType == 0 {
				var v Authorization
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTab
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= Authorization(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Authorizations = append(m.Authorizations, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTab
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTab
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthTab
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				if elementCount != 0 && len(m.Authorizations) == 0 {
					m.Authorizations = make([]Authorization, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v Authorization
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTab
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= Authorization(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Authorizations = append(m.Authorizations, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Authorizations", wireType)
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HistoryID", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTab
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTab
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTab
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HistoryID = append(m.HistoryID, &HistoryID{})
			if err := m.HistoryID[len(m.HistoryID)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTab(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTab
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTab
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SpecialUser) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTab
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SpecialUser: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SpecialUser: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTab
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= SpecialUserID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType == 0 {
				var v Authorization
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTab
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= Authorization(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Authorizations = append(m.Authorizations, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTab
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTab
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthTab
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				if elementCount != 0 && len(m.Authorizations) == 0 {
					m.Authorizations = make([]Authorization, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v Authorization
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTab
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= Authorization(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Authorizations = append(m.Authorizations, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Authorizations", wireType)
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HistoryID", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTab
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTab
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTab
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HistoryID = append(m.HistoryID, &HistoryID{})
			if err := m.HistoryID[len(m.HistoryID)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTab(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTab
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTab
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AuthorizationGrant) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTab
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AuthorizationGrant: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AuthorizationGrant: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field From", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTab
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTab
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTab
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.From == nil {
				m.From = &UserID{}
			}
			if err := m.From.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType == 0 {
				var v Authorization
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTab
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= Authorization(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Of = append(m.Of, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTab
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTab
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthTab
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				if elementCount != 0 && len(m.Of) == 0 {
					m.Of = make([]Authorization, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v Authorization
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTab
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= Authorization(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Of = append(m.Of, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Of", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTab(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTab
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTab
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IDToken) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTab
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IDToken: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IDToken: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Issuer", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTab
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTab
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTab
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Issuer = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Subject", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTab
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTab
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTab
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Subject = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Audicence", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTab
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTab
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTab
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Audicence = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Expiration", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTab
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTab
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTab
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Expiration == nil {
				m.Expiration = &protobuf.Timestamp{}
			}
			if err := m.Expiration.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Issued", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTab
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTab
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTab
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Issued == nil {
				m.Issued = &protobuf.Timestamp{}
			}
			if err := m.Issued.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nonce", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTab
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTab
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTab
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Nonce = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthorizedParty", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTab
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTab
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTab
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AuthorizedParty = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTab(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTab
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTab
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OIDCProvider) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTab
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OIDCProvider: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OIDCProvider: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTab
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTab
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTab
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Id == nil {
				m.Id = &OIDCProviderID{}
			}
			if err := m.Id.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTab
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTab
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTab
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Callback", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTab
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTab
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTab
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Callback = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthorizationEndpoint", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTab
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTab
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTab
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AuthorizationEndpoint = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTab
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTab
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTab
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClientID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTab(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTab
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTab
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTab(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTab
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTab
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTab
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthTab
			}
			iNdEx += length
			if iNdEx < 0 {
				return 0, ErrInvalidLengthTab
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowTab
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipTab(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
				if iNdEx < 0 {
					return 0, ErrInvalidLengthTab
				}
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthTab = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTab   = fmt.Errorf("proto: integer overflow")
)
