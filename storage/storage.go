package storage

import (
	"bytes"
	"encoding"
	"errors"
	"io"
	"os"
)

// to be used with Tx.Open()
const (
	O_RDONLY int = os.O_RDONLY // open read only
	O_WRONLY int = os.O_WRONLY // open write only
	O_RDWR   int = os.O_RDWR   // open read-write

	O_APPEND int = os.O_APPEND // append data
	O_CREATE int = os.O_CREATE // create the Record
	O_EXCL   int = os.O_EXCL   // for use with O_CREATE; Record must not already exist
	O_TRUNC  int = os.O_TRUNC  // truncate (delete contents of) Record
)

var ErrExclusiveOpen = errors.New("only one of O_RDONLY, O_WRONLY or O_RDWR may be specified")

func ValidateFlags(toValidate int) (err error) {
	var ctr uint
	for _, flag := range []int{O_RDONLY, O_WRONLY, O_RDWR} {
		if toValidate&flag != 0 {
			ctr++
		}

		if ctr > 1 {
			return ErrExclusiveOpen
		}
	}

	return
}

type ITxn interface {
	Open(key []byte, flag int) (IRecord, error)
	Remove(key []byte) (err error)

	Flush() (err error)
	io.Closer
}

type IStorage interface {
	Txn() (ITxn, error)
	io.Closer
	Flush() (err error)
}

// A Record represents an Open()'ed database record.
// the interface represents the *minimum* implemented by
// a Record. It's also suggested that other io methods are
// implemented as appropriate
type IRecord interface {
	io.ReadWriteCloser
	Key() (io.Reader, error)
}

type Txn struct{ ITxn }
type Storage struct{ IStorage }

func (s Storage) Tx() (New Txn, err error) {
	New.ITxn, err = s.IStorage.Txn()
	return
}

func or(ints ...int) (together int) {
	for _, i := range ints {
		together |= i
	}
	return
}

type binaryMarshalerReader struct {
	encoding.BinaryMarshaler
	*bytes.Reader
}

func newBinaryMarshalerReader(bm encoding.BinaryMarshaler) io.Reader {
	return &binaryMarshalerReader{BinaryMarshaler: bm}
}

func (b *binaryMarshalerReader) Read(p []byte) (n int, err error) {
	if b.Reader == nil {
		var bt []byte
		bt, err = b.BinaryMarshaler.MarshalBinary()
		if err != nil {
			return
		}
		b.Reader = bytes.NewReader(bt)
	}

	return b.Reader.Read(p)
}

type binaryUnmarshalerWriter struct {
	encoding.BinaryUnmarshaler
	bytes.Buffer
}

func (b binaryUnmarshalerWriter) Flush() (err error) {
	return b.BinaryUnmarshaler.UnmarshalBinary(b.Buffer.Bytes())
}

func newBinaryMarshalerWriter(b encoding.BinaryUnmarshaler) io.Writer {
	return &binaryUnmarshalerWriter{BinaryUnmarshaler: b}
}

// Get retrieves the value by the given key
func (t Txn) Get(key encoding.BinaryMarshaler, val encoding.BinaryUnmarshaler, flags ...int) (err error) {
	var keyBt []byte
	if keyBt, err = key.MarshalBinary(); err != nil {
		return
	}

	var r IRecord
	if r, err = t.ITxn.Open(keyBt, or(flags...)|O_RDONLY); err != nil {
		return
	}

	bmw := newBinaryMarshalerWriter(val)
	if _, err = io.Copy(bmw, r); err != nil {
		return
	}

	if _, err = bmw.Flush(); err != nil {
		return
	}

	return
}

// Put stores the value with the given key
func (t Txn) Put(key, val encoding.BinaryMarshaler) (err error) { panic("todo") }

// Post stores the value, generating a key as it is added.
// The generated bytes are
func (t Txn) Post(key interface {
	encoding.BinaryMarshaler
	encoding.BinaryUnmarshaler
}, val encoding.BinaryMarshaler) (err error) {
	panic("todo")
}

// Delete deletes the value at the given key
func (t Txn) Delete(key encoding.BinaryMarshaler) (err error) {
	panic("todo")
}
