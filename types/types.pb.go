// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: github.com/zemnmez/tab/types/types.proto

package types

import (
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	_ "github.com/gogo/protobuf/types"
	github_com_gogo_protobuf_types "github.com/gogo/protobuf/types"
	io "io"
	math "math"
	math_bits "math/bits"
	reflect "reflect"
	strconv "strconv"
	strings "strings"
	time "time"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf
var _ = time.Kitchen

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type Authorization int32

const (
	VIEW_USERS               Authorization = 0
	MODIFY_VALID_AUTH        Authorization = 1
	ADD_ITEMS                Authorization = 2
	MODIFY_OTHER_USERS       Authorization = 3
	MODIFY_SPECIAL_USERS     Authorization = 4
	MODIFY_SELF              Authorization = 5
	VIEW_OTHER_USERS_HISTORY Authorization = 6
	VIEW_OWN_HISTORY         Authorization = 7
)

var Authorization_name = map[int32]string{
	0: "VIEW_USERS",
	1: "MODIFY_VALID_AUTH",
	2: "ADD_ITEMS",
	3: "MODIFY_OTHER_USERS",
	4: "MODIFY_SPECIAL_USERS",
	5: "MODIFY_SELF",
	6: "VIEW_OTHER_USERS_HISTORY",
	7: "VIEW_OWN_HISTORY",
}

var Authorization_value = map[string]int32{
	"VIEW_USERS":               0,
	"MODIFY_VALID_AUTH":        1,
	"ADD_ITEMS":                2,
	"MODIFY_OTHER_USERS":       3,
	"MODIFY_SPECIAL_USERS":     4,
	"MODIFY_SELF":              5,
	"VIEW_OTHER_USERS_HISTORY": 6,
	"VIEW_OWN_HISTORY":         7,
}

func (Authorization) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_e927c4c8d1099e6c, []int{0}
}

type SpecialUserID int32

const (
	ROOT      SpecialUserID = 0
	ANONYMOUS SpecialUserID = 1
)

var SpecialUserID_name = map[int32]string{
	0: "ROOT",
	1: "ANONYMOUS",
}

var SpecialUserID_value = map[string]int32{
	"ROOT":      0,
	"ANONYMOUS": 1,
}

func (SpecialUserID) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_e927c4c8d1099e6c, []int{1}
}

type ID struct {
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
}

func (m *ID) Reset()      { *m = ID{} }
func (*ID) ProtoMessage() {}
func (*ID) Descriptor() ([]byte, []int) {
	return fileDescriptor_e927c4c8d1099e6c, []int{0}
}
func (m *ID) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ID) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ID.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ID) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ID.Merge(m, src)
}
func (m *ID) XXX_Size() int {
	return m.Size()
}
func (m *ID) XXX_DiscardUnknown() {
	xxx_messageInfo_ID.DiscardUnknown(m)
}

var xxx_messageInfo_ID proto.InternalMessageInfo

func (m *ID) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

type AuthorizationGrant struct {
	From *UserID         `protobuf:"bytes,1,opt,name=from,proto3" json:"from,omitempty"`
	Of   []Authorization `protobuf:"varint,2,rep,packed,name=of,proto3,enum=types.Authorization" json:"of,omitempty"`
}

func (m *AuthorizationGrant) Reset()      { *m = AuthorizationGrant{} }
func (*AuthorizationGrant) ProtoMessage() {}
func (*AuthorizationGrant) Descriptor() ([]byte, []int) {
	return fileDescriptor_e927c4c8d1099e6c, []int{1}
}
func (m *AuthorizationGrant) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AuthorizationGrant) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AuthorizationGrant.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AuthorizationGrant) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AuthorizationGrant.Merge(m, src)
}
func (m *AuthorizationGrant) XXX_Size() int {
	return m.Size()
}
func (m *AuthorizationGrant) XXX_DiscardUnknown() {
	xxx_messageInfo_AuthorizationGrant.DiscardUnknown(m)
}

var xxx_messageInfo_AuthorizationGrant proto.InternalMessageInfo

func (m *AuthorizationGrant) GetFrom() *UserID {
	if m != nil {
		return m.From
	}
	return nil
}

func (m *AuthorizationGrant) GetOf() []Authorization {
	if m != nil {
		return m.Of
	}
	return nil
}

type HistoryID struct {
	ID `protobuf:"bytes,1,opt,name=id,proto3,embedded=id" json:"id"`
}

func (m *HistoryID) Reset()      { *m = HistoryID{} }
func (*HistoryID) ProtoMessage() {}
func (*HistoryID) Descriptor() ([]byte, []int) {
	return fileDescriptor_e927c4c8d1099e6c, []int{2}
}
func (m *HistoryID) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HistoryID) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_HistoryID.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *HistoryID) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HistoryID.Merge(m, src)
}
func (m *HistoryID) XXX_Size() int {
	return m.Size()
}
func (m *HistoryID) XXX_DiscardUnknown() {
	xxx_messageInfo_HistoryID.DiscardUnknown(m)
}

var xxx_messageInfo_HistoryID proto.InternalMessageInfo

type HistoryItem struct {
	Action      string  `protobuf:"bytes,1,opt,name=action,proto3" json:"action,omitempty"`
	By          *UserID `protobuf:"bytes,2,opt,name=by,proto3" json:"by,omitempty"`
	RequestData string  `protobuf:"bytes,3,opt,name=requestData,proto3" json:"requestData,omitempty"`
	IPAddress   string  `protobuf:"bytes,4,opt,name=IPAddress,json=iPAddress,proto3" json:"IPAddress,omitempty"`
}

func (m *HistoryItem) Reset()      { *m = HistoryItem{} }
func (*HistoryItem) ProtoMessage() {}
func (*HistoryItem) Descriptor() ([]byte, []int) {
	return fileDescriptor_e927c4c8d1099e6c, []int{3}
}
func (m *HistoryItem) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HistoryItem) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_HistoryItem.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *HistoryItem) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HistoryItem.Merge(m, src)
}
func (m *HistoryItem) XXX_Size() int {
	return m.Size()
}
func (m *HistoryItem) XXX_DiscardUnknown() {
	xxx_messageInfo_HistoryItem.DiscardUnknown(m)
}

var xxx_messageInfo_HistoryItem proto.InternalMessageInfo

func (m *HistoryItem) GetAction() string {
	if m != nil {
		return m.Action
	}
	return ""
}

func (m *HistoryItem) GetBy() *UserID {
	if m != nil {
		return m.By
	}
	return nil
}

func (m *HistoryItem) GetRequestData() string {
	if m != nil {
		return m.RequestData
	}
	return ""
}

func (m *HistoryItem) GetIPAddress() string {
	if m != nil {
		return m.IPAddress
	}
	return ""
}

type RegularUserID struct {
	ID `protobuf:"bytes,1,opt,name=id,proto3,embedded=id" json:"id"`
}

func (m *RegularUserID) Reset()      { *m = RegularUserID{} }
func (*RegularUserID) ProtoMessage() {}
func (*RegularUserID) Descriptor() ([]byte, []int) {
	return fileDescriptor_e927c4c8d1099e6c, []int{4}
}
func (m *RegularUserID) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RegularUserID) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RegularUserID.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RegularUserID) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RegularUserID.Merge(m, src)
}
func (m *RegularUserID) XXX_Size() int {
	return m.Size()
}
func (m *RegularUserID) XXX_DiscardUnknown() {
	xxx_messageInfo_RegularUserID.DiscardUnknown(m)
}

var xxx_messageInfo_RegularUserID proto.InternalMessageInfo

type UserID struct {
	// Types that are valid to be assigned to ID:
	//	*UserID_SpecialUserID
	//	*UserID_RegularUserID
	ID isUserID_ID `protobuf_oneof:"ID"`
}

func (m *UserID) Reset()      { *m = UserID{} }
func (*UserID) ProtoMessage() {}
func (*UserID) Descriptor() ([]byte, []int) {
	return fileDescriptor_e927c4c8d1099e6c, []int{5}
}
func (m *UserID) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UserID) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UserID.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UserID) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UserID.Merge(m, src)
}
func (m *UserID) XXX_Size() int {
	return m.Size()
}
func (m *UserID) XXX_DiscardUnknown() {
	xxx_messageInfo_UserID.DiscardUnknown(m)
}

var xxx_messageInfo_UserID proto.InternalMessageInfo

type isUserID_ID interface {
	isUserID_ID()
	Equal(interface{}) bool
	VerboseEqual(interface{}) error
	MarshalTo([]byte) (int, error)
	Size() int
	Compare(interface{}) int
}

type UserID_SpecialUserID struct {
	SpecialUserID SpecialUserID `protobuf:"varint,1,opt,name=specialUserID,proto3,enum=types.SpecialUserID,oneof"`
}
type UserID_RegularUserID struct {
	RegularUserID *RegularUserID `protobuf:"bytes,2,opt,name=regularUserID,proto3,oneof"`
}

func (*UserID_SpecialUserID) isUserID_ID() {}
func (*UserID_RegularUserID) isUserID_ID() {}

func (m *UserID) GetID() isUserID_ID {
	if m != nil {
		return m.ID
	}
	return nil
}

func (m *UserID) GetSpecialUserID() SpecialUserID {
	if x, ok := m.GetID().(*UserID_SpecialUserID); ok {
		return x.SpecialUserID
	}
	return ROOT
}

func (m *UserID) GetRegularUserID() *RegularUserID {
	if x, ok := m.GetID().(*UserID_RegularUserID); ok {
		return x.RegularUserID
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*UserID) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*UserID_SpecialUserID)(nil),
		(*UserID_RegularUserID)(nil),
	}
}

type RegularUser struct {
	Id             *UserID         `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	Name           string          `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	Authorizations []Authorization `protobuf:"varint,3,rep,packed,name=authorizations,proto3,enum=types.Authorization" json:"authorizations,omitempty"`
	HistoryID      []*HistoryID    `protobuf:"bytes,4,rep,name=historyID,proto3" json:"historyID,omitempty"`
	Created        *time.Time      `protobuf:"bytes,5,opt,name=created,proto3,stdtime" json:"created,omitempty"`
}

func (m *RegularUser) Reset()      { *m = RegularUser{} }
func (*RegularUser) ProtoMessage() {}
func (*RegularUser) Descriptor() ([]byte, []int) {
	return fileDescriptor_e927c4c8d1099e6c, []int{6}
}
func (m *RegularUser) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RegularUser) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RegularUser.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RegularUser) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RegularUser.Merge(m, src)
}
func (m *RegularUser) XXX_Size() int {
	return m.Size()
}
func (m *RegularUser) XXX_DiscardUnknown() {
	xxx_messageInfo_RegularUser.DiscardUnknown(m)
}

var xxx_messageInfo_RegularUser proto.InternalMessageInfo

func (m *RegularUser) GetId() *UserID {
	if m != nil {
		return m.Id
	}
	return nil
}

func (m *RegularUser) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *RegularUser) GetAuthorizations() []Authorization {
	if m != nil {
		return m.Authorizations
	}
	return nil
}

func (m *RegularUser) GetHistoryID() []*HistoryID {
	if m != nil {
		return m.HistoryID
	}
	return nil
}

func (m *RegularUser) GetCreated() *time.Time {
	if m != nil {
		return m.Created
	}
	return nil
}

type SpecialUser struct {
	Id             SpecialUserID   `protobuf:"varint,1,opt,name=id,proto3,enum=types.SpecialUserID" json:"id,omitempty"`
	Authorizations []Authorization `protobuf:"varint,2,rep,packed,name=authorizations,proto3,enum=types.Authorization" json:"authorizations,omitempty"`
	HistoryID      []*HistoryID    `protobuf:"bytes,3,rep,name=historyID,proto3" json:"historyID,omitempty"`
}

func (m *SpecialUser) Reset()      { *m = SpecialUser{} }
func (*SpecialUser) ProtoMessage() {}
func (*SpecialUser) Descriptor() ([]byte, []int) {
	return fileDescriptor_e927c4c8d1099e6c, []int{7}
}
func (m *SpecialUser) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SpecialUser) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SpecialUser.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SpecialUser) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SpecialUser.Merge(m, src)
}
func (m *SpecialUser) XXX_Size() int {
	return m.Size()
}
func (m *SpecialUser) XXX_DiscardUnknown() {
	xxx_messageInfo_SpecialUser.DiscardUnknown(m)
}

var xxx_messageInfo_SpecialUser proto.InternalMessageInfo

func (m *SpecialUser) GetId() SpecialUserID {
	if m != nil {
		return m.Id
	}
	return ROOT
}

func (m *SpecialUser) GetAuthorizations() []Authorization {
	if m != nil {
		return m.Authorizations
	}
	return nil
}

func (m *SpecialUser) GetHistoryID() []*HistoryID {
	if m != nil {
		return m.HistoryID
	}
	return nil
}

type ItemID struct {
	ID `protobuf:"bytes,1,opt,name=id,proto3,embedded=id" json:"id"`
}

func (m *ItemID) Reset()      { *m = ItemID{} }
func (*ItemID) ProtoMessage() {}
func (*ItemID) Descriptor() ([]byte, []int) {
	return fileDescriptor_e927c4c8d1099e6c, []int{8}
}
func (m *ItemID) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ItemID) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ItemID.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ItemID) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ItemID.Merge(m, src)
}
func (m *ItemID) XXX_Size() int {
	return m.Size()
}
func (m *ItemID) XXX_DiscardUnknown() {
	xxx_messageInfo_ItemID.DiscardUnknown(m)
}

var xxx_messageInfo_ItemID proto.InternalMessageInfo

type Item struct {
	Id       *ItemID   `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	Name     string    `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	Location string    `protobuf:"bytes,3,opt,name=location,proto3" json:"location,omitempty"`
	Parent   *ItemID   `protobuf:"bytes,4,opt,name=parent,proto3" json:"parent,omitempty"`
	Children []*ItemID `protobuf:"bytes,5,rep,name=children,proto3" json:"children,omitempty"`
}

func (m *Item) Reset()      { *m = Item{} }
func (*Item) ProtoMessage() {}
func (*Item) Descriptor() ([]byte, []int) {
	return fileDescriptor_e927c4c8d1099e6c, []int{9}
}
func (m *Item) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Item) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Item.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Item) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Item.Merge(m, src)
}
func (m *Item) XXX_Size() int {
	return m.Size()
}
func (m *Item) XXX_DiscardUnknown() {
	xxx_messageInfo_Item.DiscardUnknown(m)
}

var xxx_messageInfo_Item proto.InternalMessageInfo

func (m *Item) GetId() *ItemID {
	if m != nil {
		return m.Id
	}
	return nil
}

func (m *Item) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Item) GetLocation() string {
	if m != nil {
		return m.Location
	}
	return ""
}

func (m *Item) GetParent() *ItemID {
	if m != nil {
		return m.Parent
	}
	return nil
}

func (m *Item) GetChildren() []*ItemID {
	if m != nil {
		return m.Children
	}
	return nil
}

type OIDCProviderID struct {
	ID `protobuf:"bytes,1,opt,name=id,proto3,embedded=id" json:"id"`
}

func (m *OIDCProviderID) Reset()      { *m = OIDCProviderID{} }
func (*OIDCProviderID) ProtoMessage() {}
func (*OIDCProviderID) Descriptor() ([]byte, []int) {
	return fileDescriptor_e927c4c8d1099e6c, []int{10}
}
func (m *OIDCProviderID) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OIDCProviderID) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OIDCProviderID.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OIDCProviderID) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OIDCProviderID.Merge(m, src)
}
func (m *OIDCProviderID) XXX_Size() int {
	return m.Size()
}
func (m *OIDCProviderID) XXX_DiscardUnknown() {
	xxx_messageInfo_OIDCProviderID.DiscardUnknown(m)
}

var xxx_messageInfo_OIDCProviderID proto.InternalMessageInfo

type OIDCProvider struct {
	Id                    *OIDCProviderID `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	Name                  string          `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	Callback              string          `protobuf:"bytes,3,opt,name=callback,proto3" json:"callback,omitempty"`
	AuthorizationEndpoint string          `protobuf:"bytes,4,opt,name=authorizationEndpoint,proto3" json:"authorizationEndpoint,omitempty"`
	ClientID              string          `protobuf:"bytes,5,opt,name=clientID,proto3" json:"clientID,omitempty"`
}

func (m *OIDCProvider) Reset()      { *m = OIDCProvider{} }
func (*OIDCProvider) ProtoMessage() {}
func (*OIDCProvider) Descriptor() ([]byte, []int) {
	return fileDescriptor_e927c4c8d1099e6c, []int{11}
}
func (m *OIDCProvider) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OIDCProvider) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OIDCProvider.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OIDCProvider) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OIDCProvider.Merge(m, src)
}
func (m *OIDCProvider) XXX_Size() int {
	return m.Size()
}
func (m *OIDCProvider) XXX_DiscardUnknown() {
	xxx_messageInfo_OIDCProvider.DiscardUnknown(m)
}

var xxx_messageInfo_OIDCProvider proto.InternalMessageInfo

func (m *OIDCProvider) GetId() *OIDCProviderID {
	if m != nil {
		return m.Id
	}
	return nil
}

func (m *OIDCProvider) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *OIDCProvider) GetCallback() string {
	if m != nil {
		return m.Callback
	}
	return ""
}

func (m *OIDCProvider) GetAuthorizationEndpoint() string {
	if m != nil {
		return m.AuthorizationEndpoint
	}
	return ""
}

func (m *OIDCProvider) GetClientID() string {
	if m != nil {
		return m.ClientID
	}
	return ""
}

type IDToken struct {
	Issuer                              string     `protobuf:"bytes,1,opt,name=issuer,proto3" json:"issuer,omitempty"`
	Subject                             string     `protobuf:"bytes,2,opt,name=subject,proto3" json:"subject,omitempty"`
	Audience                            string     `protobuf:"bytes,3,opt,name=audience,proto3" json:"audience,omitempty"`
	Expiration                          *time.Time `protobuf:"bytes,4,opt,name=expiration,proto3,stdtime" json:"expiration,omitempty"`
	Issued                              *time.Time `protobuf:"bytes,5,opt,name=issued,proto3,stdtime" json:"issued,omitempty"`
	Nonce                               string     `protobuf:"bytes,6,opt,name=nonce,proto3" json:"nonce,omitempty"`
	AuthenticationContextClassReference int64      `protobuf:"varint,7,opt,name=authenticationContextClassReference,proto3" json:"authenticationContextClassReference,omitempty"`
	AuthenticationMethodsReference      []string   `protobuf:"bytes,8,rep,name=authenticationMethodsReference,proto3" json:"authenticationMethodsReference,omitempty"`
	AuthorizedParty                     string     `protobuf:"bytes,9,opt,name=authorizedParty,proto3" json:"authorizedParty,omitempty"`
}

func (m *IDToken) Reset()      { *m = IDToken{} }
func (*IDToken) ProtoMessage() {}
func (*IDToken) Descriptor() ([]byte, []int) {
	return fileDescriptor_e927c4c8d1099e6c, []int{12}
}
func (m *IDToken) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IDToken) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_IDToken.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *IDToken) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IDToken.Merge(m, src)
}
func (m *IDToken) XXX_Size() int {
	return m.Size()
}
func (m *IDToken) XXX_DiscardUnknown() {
	xxx_messageInfo_IDToken.DiscardUnknown(m)
}

var xxx_messageInfo_IDToken proto.InternalMessageInfo

func (m *IDToken) GetIssuer() string {
	if m != nil {
		return m.Issuer
	}
	return ""
}

func (m *IDToken) GetSubject() string {
	if m != nil {
		return m.Subject
	}
	return ""
}

func (m *IDToken) GetAudience() string {
	if m != nil {
		return m.Audience
	}
	return ""
}

func (m *IDToken) GetExpiration() *time.Time {
	if m != nil {
		return m.Expiration
	}
	return nil
}

func (m *IDToken) GetIssued() *time.Time {
	if m != nil {
		return m.Issued
	}
	return nil
}

func (m *IDToken) GetNonce() string {
	if m != nil {
		return m.Nonce
	}
	return ""
}

func (m *IDToken) GetAuthenticationContextClassReference() int64 {
	if m != nil {
		return m.AuthenticationContextClassReference
	}
	return 0
}

func (m *IDToken) GetAuthenticationMethodsReference() []string {
	if m != nil {
		return m.AuthenticationMethodsReference
	}
	return nil
}

func (m *IDToken) GetAuthorizedParty() string {
	if m != nil {
		return m.AuthorizedParty
	}
	return ""
}

func init() {
	proto.RegisterEnum("types.Authorization", Authorization_name, Authorization_value)
	proto.RegisterEnum("types.SpecialUserID", SpecialUserID_name, SpecialUserID_value)
	proto.RegisterType((*ID)(nil), "types.ID")
	proto.RegisterType((*AuthorizationGrant)(nil), "types.AuthorizationGrant")
	proto.RegisterType((*HistoryID)(nil), "types.HistoryID")
	proto.RegisterType((*HistoryItem)(nil), "types.HistoryItem")
	proto.RegisterType((*RegularUserID)(nil), "types.RegularUserID")
	proto.RegisterType((*UserID)(nil), "types.UserID")
	proto.RegisterType((*RegularUser)(nil), "types.RegularUser")
	proto.RegisterType((*SpecialUser)(nil), "types.SpecialUser")
	proto.RegisterType((*ItemID)(nil), "types.ItemID")
	proto.RegisterType((*Item)(nil), "types.Item")
	proto.RegisterType((*OIDCProviderID)(nil), "types.OIDCProviderID")
	proto.RegisterType((*OIDCProvider)(nil), "types.OIDCProvider")
	proto.RegisterType((*IDToken)(nil), "types.IDToken")
}

func init() {
	proto.RegisterFile("github.com/zemnmez/tab/types/types.proto", fileDescriptor_e927c4c8d1099e6c)
}

var fileDescriptor_e927c4c8d1099e6c = []byte{
	// 1002 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x9c, 0x56, 0xb1, 0x6f, 0xdb, 0xc6,
	0x17, 0xe6, 0x51, 0xb4, 0x6c, 0x3e, 0xfd, 0xe4, 0xe8, 0x77, 0xb0, 0x03, 0xc2, 0x70, 0x69, 0x55,
	0x69, 0x00, 0x35, 0x40, 0xe4, 0xc2, 0x4d, 0x81, 0xa2, 0xc8, 0x50, 0xd9, 0x94, 0x6b, 0x02, 0xb6,
	0x65, 0x50, 0x72, 0x02, 0x17, 0x68, 0x05, 0x8a, 0x3c, 0x49, 0x6c, 0x24, 0x9e, 0x4a, 0x9e, 0x8a,
	0xc8, 0x53, 0x87, 0x4e, 0x9d, 0xf2, 0x2f, 0x74, 0x6a, 0x96, 0xce, 0xed, 0xd0, 0x3f, 0x20, 0xa3,
	0xc7, 0x4c, 0x69, 0x2c, 0x2f, 0x45, 0xa7, 0xfc, 0x09, 0x05, 0x8f, 0x47, 0x99, 0x72, 0x1c, 0x47,
	0xe8, 0x22, 0xf0, 0xdd, 0xfb, 0xbe, 0x77, 0xdf, 0xbb, 0xf7, 0xdd, 0x41, 0x50, 0xee, 0x7a, 0xac,
	0x37, 0x6a, 0x57, 0x1c, 0x3a, 0xd8, 0x3c, 0x25, 0x03, 0x7f, 0x40, 0x4e, 0x37, 0x99, 0xdd, 0xde,
	0x64, 0xe3, 0x21, 0x09, 0xe3, 0xdf, 0xca, 0x30, 0xa0, 0x8c, 0xe2, 0x05, 0x1e, 0xac, 0xdd, 0x4f,
	0x11, 0xba, 0xb4, 0x4b, 0x37, 0x79, 0xb6, 0x3d, 0xea, 0xf0, 0x88, 0x07, 0xfc, 0x2b, 0x66, 0xad,
	0x6d, 0x74, 0x29, 0xed, 0xf6, 0xc9, 0x25, 0x8a, 0x79, 0x03, 0x12, 0x32, 0x7b, 0x30, 0x8c, 0x01,
	0xa5, 0x15, 0x90, 0x4d, 0x03, 0x2f, 0x83, 0xec, 0xb9, 0x1a, 0x2a, 0xa2, 0xb2, 0x6a, 0xc9, 0x9e,
	0x5b, 0xfa, 0x06, 0x70, 0x75, 0xc4, 0x7a, 0x34, 0xf0, 0x4e, 0x6d, 0xe6, 0x51, 0xff, 0xab, 0xc0,
	0xf6, 0x19, 0xfe, 0x10, 0x94, 0x4e, 0x40, 0x07, 0x1c, 0x97, 0xdb, 0xca, 0x57, 0x62, 0x79, 0xc7,
	0x21, 0x09, 0x4c, 0xc3, 0xe2, 0x29, 0xfc, 0x11, 0xc8, 0xb4, 0xa3, 0xc9, 0xc5, 0x4c, 0x79, 0x79,
	0x6b, 0x45, 0x00, 0x66, 0x2a, 0x59, 0x32, 0xed, 0x94, 0x3e, 0x01, 0x75, 0xcf, 0x0b, 0x19, 0x0d,
	0xc6, 0xa6, 0x81, 0xef, 0x4c, 0xf7, 0xce, 0x6d, 0xa9, 0x82, 0x62, 0x1a, 0xdb, 0x4b, 0x2f, 0x5e,
	0x6d, 0x48, 0x67, 0xaf, 0x36, 0x10, 0x17, 0xf4, 0x13, 0x82, 0x5c, 0x42, 0x61, 0x64, 0x80, 0x6f,
	0x43, 0xd6, 0x76, 0xa2, 0x7a, 0x42, 0xb4, 0x88, 0xf0, 0x07, 0x20, 0xb7, 0xc7, 0x9a, 0x7c, 0x9d,
	0x40, 0xb9, 0x3d, 0xc6, 0x45, 0xc8, 0x05, 0xe4, 0xfb, 0x11, 0x09, 0x99, 0x61, 0x33, 0x5b, 0xcb,
	0x70, 0x6e, 0x7a, 0x09, 0xaf, 0x83, 0x6a, 0x1e, 0x55, 0x5d, 0x37, 0x20, 0x61, 0xa8, 0x29, 0x3c,
	0xaf, 0x7a, 0xc9, 0x42, 0xe9, 0x01, 0xe4, 0x2d, 0xd2, 0x1d, 0xf5, 0xed, 0x20, 0x2e, 0x3a, 0x9f,
	0xf8, 0x9f, 0x11, 0x64, 0x05, 0xfe, 0x21, 0xe4, 0xc3, 0x21, 0x71, 0x3c, 0xbb, 0x1f, 0x2f, 0x70,
	0xea, 0xe5, 0x51, 0x35, 0xd2, 0xb9, 0x3d, 0xc9, 0x9a, 0x05, 0x47, 0xec, 0x20, 0xbd, 0xbd, 0x68,
	0x34, 0x61, 0xcf, 0x48, 0x8b, 0xd8, 0x33, 0xe0, 0x6d, 0x25, 0x1a, 0x75, 0xe9, 0x1f, 0x04, 0xb9,
	0x14, 0x30, 0x3a, 0xb1, 0x69, 0x07, 0x57, 0x4f, 0xcc, 0x73, 0x31, 0x06, 0xc5, 0xb7, 0x07, 0x84,
	0xef, 0xa4, 0x5a, 0xfc, 0x1b, 0x3f, 0x84, 0x65, 0x3b, 0x3d, 0xd3, 0x50, 0xcb, 0xdc, 0x30, 0xf0,
	0x2b, 0x58, 0x5c, 0x01, 0xb5, 0x97, 0x0c, 0x5f, 0x53, 0x8a, 0x99, 0x72, 0x6e, 0xab, 0x20, 0x88,
	0x53, 0x53, 0x58, 0x97, 0x10, 0xfc, 0x05, 0x2c, 0x3a, 0x01, 0xb1, 0x19, 0x71, 0xb5, 0x05, 0xae,
	0x72, 0xad, 0x12, 0x9b, 0xba, 0x92, 0x98, 0xba, 0xd2, 0x4c, 0x4c, 0xbd, 0xad, 0x3c, 0xfb, 0x6b,
	0x03, 0x59, 0x09, 0xa1, 0xf4, 0x0b, 0x82, 0x5c, 0xea, 0x4c, 0x23, 0x7b, 0x8a, 0x66, 0xdf, 0x71,
	0xe6, 0xbc, 0xe7, 0xb7, 0xfb, 0x93, 0xff, 0x6b, 0x7f, 0x99, 0xf7, 0xf6, 0x57, 0xba, 0x0f, 0xd9,
	0xc8, 0xd2, 0xf3, 0x9a, 0xe9, 0x57, 0x04, 0x0a, 0xbf, 0x02, 0xd7, 0x0d, 0x2e, 0x2e, 0xf4, 0xce,
	0xc1, 0xad, 0xc1, 0x52, 0x9f, 0x3a, 0x5c, 0xa7, 0xf0, 0xfe, 0x34, 0xc6, 0x77, 0x21, 0x3b, 0xb4,
	0x03, 0xe2, 0x33, 0xee, 0xfa, 0xb7, 0x4a, 0x8a, 0x24, 0xfe, 0x18, 0x96, 0x9c, 0x9e, 0xd7, 0x77,
	0x03, 0xe2, 0x6b, 0x0b, 0xbc, 0xb9, 0x2b, 0xc0, 0x69, 0xba, 0xf4, 0x19, 0x2c, 0xd7, 0x4d, 0x63,
	0xe7, 0x28, 0xa0, 0x3f, 0x78, 0xee, 0xfc, 0xb7, 0xe5, 0x77, 0x04, 0xff, 0x4b, 0xf3, 0xf0, 0xdd,
	0x14, 0x6b, 0x55, 0xb0, 0x66, 0x0b, 0xdf, 0xd4, 0xb0, 0x63, 0xf7, 0xfb, 0x6d, 0xdb, 0x79, 0x92,
	0x34, 0x9c, 0xc4, 0xf8, 0x01, 0xac, 0xce, 0x4c, 0xae, 0xe6, 0xbb, 0x43, 0xea, 0x89, 0xfe, 0x55,
	0xeb, 0xfa, 0x24, 0xaf, 0xd8, 0xf7, 0x88, 0xcf, 0x4c, 0x83, 0xdb, 0x31, 0xaa, 0x28, 0xe2, 0xd2,
	0x6f, 0x19, 0x58, 0x34, 0x8d, 0x26, 0x7d, 0x42, 0xfc, 0xe8, 0x81, 0xf2, 0xc2, 0x70, 0x44, 0x82,
	0xe4, 0x81, 0x8a, 0x23, 0xac, 0xc1, 0x62, 0x38, 0x6a, 0x7f, 0x47, 0x1c, 0x26, 0x84, 0x26, 0x61,
	0x54, 0xd9, 0x1e, 0xb9, 0x1e, 0xf1, 0x1d, 0x92, 0x68, 0x4d, 0x62, 0xfc, 0x25, 0x00, 0x79, 0x3a,
	0xf4, 0x82, 0x78, 0x74, 0xca, 0x9c, 0xd7, 0x20, 0xc5, 0xc1, 0x9f, 0x0b, 0x3d, 0xf3, 0x5f, 0x22,
	0x81, 0xc7, 0x2b, 0xb0, 0xe0, 0xd3, 0x48, 0x54, 0x96, 0x8b, 0x8a, 0x03, 0x7c, 0x04, 0x77, 0xa2,
	0x03, 0x22, 0x3e, 0xf3, 0x62, 0x03, 0xed, 0x50, 0x9f, 0x91, 0xa7, 0x6c, 0xa7, 0x6f, 0x87, 0xa1,
	0x45, 0x3a, 0x24, 0xe0, 0x8d, 0x2c, 0x16, 0x51, 0x39, 0x63, 0xcd, 0x03, 0xc5, 0xbb, 0xa0, 0xcf,
	0xc2, 0x0e, 0x08, 0xeb, 0x51, 0x37, 0x55, 0x6c, 0xa9, 0x98, 0x29, 0xab, 0xd6, 0x7b, 0x50, 0xb8,
	0x0c, 0xb7, 0x92, 0xd1, 0x11, 0xf7, 0xc8, 0x0e, 0xd8, 0x58, 0x53, 0xb9, 0xf2, 0xab, 0xcb, 0xf7,
	0xfe, 0x44, 0x90, 0x9f, 0xb9, 0xcb, 0x78, 0x19, 0xe0, 0x91, 0x59, 0x7b, 0xdc, 0x3a, 0x6e, 0xd4,
	0xac, 0x46, 0x41, 0xc2, 0xab, 0xf0, 0xff, 0x83, 0xba, 0x61, 0xee, 0x9e, 0xb4, 0x1e, 0x55, 0xf7,
	0x4d, 0xa3, 0x55, 0x3d, 0x6e, 0xee, 0x15, 0x10, 0xce, 0x83, 0x5a, 0x35, 0x8c, 0x96, 0xd9, 0xac,
	0x1d, 0x34, 0x0a, 0x32, 0xbe, 0x0d, 0x58, 0xa0, 0xea, 0xcd, 0xbd, 0x9a, 0x25, 0xd8, 0x19, 0xac,
	0xc1, 0x8a, 0x58, 0x6f, 0x1c, 0xd5, 0x76, 0xcc, 0xea, 0xbe, 0xc8, 0x28, 0xf8, 0x16, 0xe4, 0x92,
	0x4c, 0x6d, 0x7f, 0xb7, 0xb0, 0x80, 0xd7, 0x41, 0xe3, 0x1b, 0xa7, 0x0a, 0xb4, 0xf6, 0xcc, 0x46,
	0xb3, 0x6e, 0x9d, 0x14, 0xb2, 0x78, 0x05, 0x0a, 0x71, 0xf6, 0xf1, 0xe1, 0x74, 0x75, 0xf1, 0x5e,
	0x19, 0xf2, 0x33, 0x6f, 0x17, 0x5e, 0x02, 0xc5, 0xaa, 0xd7, 0x9b, 0x05, 0x89, 0x0b, 0x3c, 0xac,
	0x1f, 0x9e, 0x1c, 0xd4, 0x8f, 0x1b, 0x05, 0xb4, 0xfd, 0xed, 0xd9, 0xb9, 0x2e, 0xbd, 0x3c, 0xd7,
	0xa5, 0xd7, 0xe7, 0x3a, 0x7a, 0x73, 0xae, 0xa3, 0x1f, 0x27, 0x3a, 0x7a, 0x3e, 0xd1, 0xd1, 0x1f,
	0x13, 0x1d, 0xbd, 0x98, 0xe8, 0xe8, 0x6c, 0xa2, 0xa3, 0xd7, 0x13, 0x1d, 0xfd, 0x3d, 0xd1, 0xa5,
	0x37, 0x13, 0x1d, 0x3d, 0xbb, 0xd0, 0xa5, 0xe7, 0x17, 0x3a, 0x3a, 0xbb, 0xd0, 0xa5, 0x97, 0x17,
	0xba, 0xf4, 0xf5, 0xfa, 0x4d, 0xff, 0x53, 0xda, 0x59, 0x6e, 0xa2, 0x4f, 0xff, 0x0d, 0x00, 0x00,
	0xff, 0xff, 0xe7, 0xfc, 0x9f, 0x62, 0xce, 0x08, 0x00, 0x00,
}

func (this *ID) Compare(that interface{}) int {
	if that == nil {
		if this == nil {
			return 0
		}
		return 1
	}

	that1, ok := that.(*ID)
	if !ok {
		that2, ok := that.(ID)
		if ok {
			that1 = &that2
		} else {
			return 1
		}
	}
	if that1 == nil {
		if this == nil {
			return 0
		}
		return 1
	} else if this == nil {
		return -1
	}
	if this.Id != that1.Id {
		if this.Id < that1.Id {
			return -1
		}
		return 1
	}
	return 0
}
func (this *AuthorizationGrant) Compare(that interface{}) int {
	if that == nil {
		if this == nil {
			return 0
		}
		return 1
	}

	that1, ok := that.(*AuthorizationGrant)
	if !ok {
		that2, ok := that.(AuthorizationGrant)
		if ok {
			that1 = &that2
		} else {
			return 1
		}
	}
	if that1 == nil {
		if this == nil {
			return 0
		}
		return 1
	} else if this == nil {
		return -1
	}
	if c := this.From.Compare(that1.From); c != 0 {
		return c
	}
	if len(this.Of) != len(that1.Of) {
		if len(this.Of) < len(that1.Of) {
			return -1
		}
		return 1
	}
	for i := range this.Of {
		if this.Of[i] != that1.Of[i] {
			if this.Of[i] < that1.Of[i] {
				return -1
			}
			return 1
		}
	}
	return 0
}
func (this *HistoryID) Compare(that interface{}) int {
	if that == nil {
		if this == nil {
			return 0
		}
		return 1
	}

	that1, ok := that.(*HistoryID)
	if !ok {
		that2, ok := that.(HistoryID)
		if ok {
			that1 = &that2
		} else {
			return 1
		}
	}
	if that1 == nil {
		if this == nil {
			return 0
		}
		return 1
	} else if this == nil {
		return -1
	}
	if c := this.ID.Compare(&that1.ID); c != 0 {
		return c
	}
	return 0
}
func (this *HistoryItem) Compare(that interface{}) int {
	if that == nil {
		if this == nil {
			return 0
		}
		return 1
	}

	that1, ok := that.(*HistoryItem)
	if !ok {
		that2, ok := that.(HistoryItem)
		if ok {
			that1 = &that2
		} else {
			return 1
		}
	}
	if that1 == nil {
		if this == nil {
			return 0
		}
		return 1
	} else if this == nil {
		return -1
	}
	if this.Action != that1.Action {
		if this.Action < that1.Action {
			return -1
		}
		return 1
	}
	if c := this.By.Compare(that1.By); c != 0 {
		return c
	}
	if this.RequestData != that1.RequestData {
		if this.RequestData < that1.RequestData {
			return -1
		}
		return 1
	}
	if this.IPAddress != that1.IPAddress {
		if this.IPAddress < that1.IPAddress {
			return -1
		}
		return 1
	}
	return 0
}
func (this *RegularUserID) Compare(that interface{}) int {
	if that == nil {
		if this == nil {
			return 0
		}
		return 1
	}

	that1, ok := that.(*RegularUserID)
	if !ok {
		that2, ok := that.(RegularUserID)
		if ok {
			that1 = &that2
		} else {
			return 1
		}
	}
	if that1 == nil {
		if this == nil {
			return 0
		}
		return 1
	} else if this == nil {
		return -1
	}
	if c := this.ID.Compare(&that1.ID); c != 0 {
		return c
	}
	return 0
}
func (this *UserID) Compare(that interface{}) int {
	if that == nil {
		if this == nil {
			return 0
		}
		return 1
	}

	that1, ok := that.(*UserID)
	if !ok {
		that2, ok := that.(UserID)
		if ok {
			that1 = &that2
		} else {
			return 1
		}
	}
	if that1 == nil {
		if this == nil {
			return 0
		}
		return 1
	} else if this == nil {
		return -1
	}
	if that1.ID == nil {
		if this.ID != nil {
			return 1
		}
	} else if this.ID == nil {
		return -1
	} else {
		thisType := -1
		switch this.ID.(type) {
		case *UserID_SpecialUserID:
			thisType = 0
		case *UserID_RegularUserID:
			thisType = 1
		default:
			panic(fmt.Sprintf("compare: unexpected type %T in oneof", this.ID))
		}
		that1Type := -1
		switch that1.ID.(type) {
		case *UserID_SpecialUserID:
			that1Type = 0
		case *UserID_RegularUserID:
			that1Type = 1
		default:
			panic(fmt.Sprintf("compare: unexpected type %T in oneof", that1.ID))
		}
		if thisType == that1Type {
			if c := this.ID.Compare(that1.ID); c != 0 {
				return c
			}
		} else if thisType < that1Type {
			return -1
		} else if thisType > that1Type {
			return 1
		}
	}
	return 0
}
func (this *UserID_SpecialUserID) Compare(that interface{}) int {
	if that == nil {
		if this == nil {
			return 0
		}
		return 1
	}

	that1, ok := that.(*UserID_SpecialUserID)
	if !ok {
		that2, ok := that.(UserID_SpecialUserID)
		if ok {
			that1 = &that2
		} else {
			return 1
		}
	}
	if that1 == nil {
		if this == nil {
			return 0
		}
		return 1
	} else if this == nil {
		return -1
	}
	if this.SpecialUserID != that1.SpecialUserID {
		if this.SpecialUserID < that1.SpecialUserID {
			return -1
		}
		return 1
	}
	return 0
}
func (this *UserID_RegularUserID) Compare(that interface{}) int {
	if that == nil {
		if this == nil {
			return 0
		}
		return 1
	}

	that1, ok := that.(*UserID_RegularUserID)
	if !ok {
		that2, ok := that.(UserID_RegularUserID)
		if ok {
			that1 = &that2
		} else {
			return 1
		}
	}
	if that1 == nil {
		if this == nil {
			return 0
		}
		return 1
	} else if this == nil {
		return -1
	}
	if c := this.RegularUserID.Compare(that1.RegularUserID); c != 0 {
		return c
	}
	return 0
}
func (this *RegularUser) Compare(that interface{}) int {
	if that == nil {
		if this == nil {
			return 0
		}
		return 1
	}

	that1, ok := that.(*RegularUser)
	if !ok {
		that2, ok := that.(RegularUser)
		if ok {
			that1 = &that2
		} else {
			return 1
		}
	}
	if that1 == nil {
		if this == nil {
			return 0
		}
		return 1
	} else if this == nil {
		return -1
	}
	if c := this.Id.Compare(that1.Id); c != 0 {
		return c
	}
	if this.Name != that1.Name {
		if this.Name < that1.Name {
			return -1
		}
		return 1
	}
	if len(this.Authorizations) != len(that1.Authorizations) {
		if len(this.Authorizations) < len(that1.Authorizations) {
			return -1
		}
		return 1
	}
	for i := range this.Authorizations {
		if this.Authorizations[i] != that1.Authorizations[i] {
			if this.Authorizations[i] < that1.Authorizations[i] {
				return -1
			}
			return 1
		}
	}
	if len(this.HistoryID) != len(that1.HistoryID) {
		if len(this.HistoryID) < len(that1.HistoryID) {
			return -1
		}
		return 1
	}
	for i := range this.HistoryID {
		if c := this.HistoryID[i].Compare(that1.HistoryID[i]); c != 0 {
			return c
		}
	}
	if c := this.Created.Compare(that1.Created); c != 0 {
		return c
	}
	return 0
}
func (this *SpecialUser) Compare(that interface{}) int {
	if that == nil {
		if this == nil {
			return 0
		}
		return 1
	}

	that1, ok := that.(*SpecialUser)
	if !ok {
		that2, ok := that.(SpecialUser)
		if ok {
			that1 = &that2
		} else {
			return 1
		}
	}
	if that1 == nil {
		if this == nil {
			return 0
		}
		return 1
	} else if this == nil {
		return -1
	}
	if this.Id != that1.Id {
		if this.Id < that1.Id {
			return -1
		}
		return 1
	}
	if len(this.Authorizations) != len(that1.Authorizations) {
		if len(this.Authorizations) < len(that1.Authorizations) {
			return -1
		}
		return 1
	}
	for i := range this.Authorizations {
		if this.Authorizations[i] != that1.Authorizations[i] {
			if this.Authorizations[i] < that1.Authorizations[i] {
				return -1
			}
			return 1
		}
	}
	if len(this.HistoryID) != len(that1.HistoryID) {
		if len(this.HistoryID) < len(that1.HistoryID) {
			return -1
		}
		return 1
	}
	for i := range this.HistoryID {
		if c := this.HistoryID[i].Compare(that1.HistoryID[i]); c != 0 {
			return c
		}
	}
	return 0
}
func (this *ItemID) Compare(that interface{}) int {
	if that == nil {
		if this == nil {
			return 0
		}
		return 1
	}

	that1, ok := that.(*ItemID)
	if !ok {
		that2, ok := that.(ItemID)
		if ok {
			that1 = &that2
		} else {
			return 1
		}
	}
	if that1 == nil {
		if this == nil {
			return 0
		}
		return 1
	} else if this == nil {
		return -1
	}
	if c := this.ID.Compare(&that1.ID); c != 0 {
		return c
	}
	return 0
}
func (this *Item) Compare(that interface{}) int {
	if that == nil {
		if this == nil {
			return 0
		}
		return 1
	}

	that1, ok := that.(*Item)
	if !ok {
		that2, ok := that.(Item)
		if ok {
			that1 = &that2
		} else {
			return 1
		}
	}
	if that1 == nil {
		if this == nil {
			return 0
		}
		return 1
	} else if this == nil {
		return -1
	}
	if c := this.Id.Compare(that1.Id); c != 0 {
		return c
	}
	if this.Name != that1.Name {
		if this.Name < that1.Name {
			return -1
		}
		return 1
	}
	if this.Location != that1.Location {
		if this.Location < that1.Location {
			return -1
		}
		return 1
	}
	if c := this.Parent.Compare(that1.Parent); c != 0 {
		return c
	}
	if len(this.Children) != len(that1.Children) {
		if len(this.Children) < len(that1.Children) {
			return -1
		}
		return 1
	}
	for i := range this.Children {
		if c := this.Children[i].Compare(that1.Children[i]); c != 0 {
			return c
		}
	}
	return 0
}
func (this *OIDCProviderID) Compare(that interface{}) int {
	if that == nil {
		if this == nil {
			return 0
		}
		return 1
	}

	that1, ok := that.(*OIDCProviderID)
	if !ok {
		that2, ok := that.(OIDCProviderID)
		if ok {
			that1 = &that2
		} else {
			return 1
		}
	}
	if that1 == nil {
		if this == nil {
			return 0
		}
		return 1
	} else if this == nil {
		return -1
	}
	if c := this.ID.Compare(&that1.ID); c != 0 {
		return c
	}
	return 0
}
func (this *OIDCProvider) Compare(that interface{}) int {
	if that == nil {
		if this == nil {
			return 0
		}
		return 1
	}

	that1, ok := that.(*OIDCProvider)
	if !ok {
		that2, ok := that.(OIDCProvider)
		if ok {
			that1 = &that2
		} else {
			return 1
		}
	}
	if that1 == nil {
		if this == nil {
			return 0
		}
		return 1
	} else if this == nil {
		return -1
	}
	if c := this.Id.Compare(that1.Id); c != 0 {
		return c
	}
	if this.Name != that1.Name {
		if this.Name < that1.Name {
			return -1
		}
		return 1
	}
	if this.Callback != that1.Callback {
		if this.Callback < that1.Callback {
			return -1
		}
		return 1
	}
	if this.AuthorizationEndpoint != that1.AuthorizationEndpoint {
		if this.AuthorizationEndpoint < that1.AuthorizationEndpoint {
			return -1
		}
		return 1
	}
	if this.ClientID != that1.ClientID {
		if this.ClientID < that1.ClientID {
			return -1
		}
		return 1
	}
	return 0
}
func (this *IDToken) Compare(that interface{}) int {
	if that == nil {
		if this == nil {
			return 0
		}
		return 1
	}

	that1, ok := that.(*IDToken)
	if !ok {
		that2, ok := that.(IDToken)
		if ok {
			that1 = &that2
		} else {
			return 1
		}
	}
	if that1 == nil {
		if this == nil {
			return 0
		}
		return 1
	} else if this == nil {
		return -1
	}
	if this.Issuer != that1.Issuer {
		if this.Issuer < that1.Issuer {
			return -1
		}
		return 1
	}
	if this.Subject != that1.Subject {
		if this.Subject < that1.Subject {
			return -1
		}
		return 1
	}
	if this.Audience != that1.Audience {
		if this.Audience < that1.Audience {
			return -1
		}
		return 1
	}
	if c := this.Expiration.Compare(that1.Expiration); c != 0 {
		return c
	}
	if c := this.Issued.Compare(that1.Issued); c != 0 {
		return c
	}
	if this.Nonce != that1.Nonce {
		if this.Nonce < that1.Nonce {
			return -1
		}
		return 1
	}
	if this.AuthenticationContextClassReference != that1.AuthenticationContextClassReference {
		if this.AuthenticationContextClassReference < that1.AuthenticationContextClassReference {
			return -1
		}
		return 1
	}
	if len(this.AuthenticationMethodsReference) != len(that1.AuthenticationMethodsReference) {
		if len(this.AuthenticationMethodsReference) < len(that1.AuthenticationMethodsReference) {
			return -1
		}
		return 1
	}
	for i := range this.AuthenticationMethodsReference {
		if this.AuthenticationMethodsReference[i] != that1.AuthenticationMethodsReference[i] {
			if this.AuthenticationMethodsReference[i] < that1.AuthenticationMethodsReference[i] {
				return -1
			}
			return 1
		}
	}
	if this.AuthorizedParty != that1.AuthorizedParty {
		if this.AuthorizedParty < that1.AuthorizedParty {
			return -1
		}
		return 1
	}
	return 0
}
func (x Authorization) String() string {
	s, ok := Authorization_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x SpecialUserID) String() string {
	s, ok := SpecialUserID_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (this *ID) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*ID)
	if !ok {
		that2, ok := that.(ID)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *ID")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *ID but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *ID but is not nil && this == nil")
	}
	if this.Id != that1.Id {
		return fmt.Errorf("Id this(%v) Not Equal that(%v)", this.Id, that1.Id)
	}
	return nil
}
func (this *ID) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ID)
	if !ok {
		that2, ok := that.(ID)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Id != that1.Id {
		return false
	}
	return true
}
func (this *AuthorizationGrant) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*AuthorizationGrant)
	if !ok {
		that2, ok := that.(AuthorizationGrant)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *AuthorizationGrant")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *AuthorizationGrant but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *AuthorizationGrant but is not nil && this == nil")
	}
	if !this.From.Equal(that1.From) {
		return fmt.Errorf("From this(%v) Not Equal that(%v)", this.From, that1.From)
	}
	if len(this.Of) != len(that1.Of) {
		return fmt.Errorf("Of this(%v) Not Equal that(%v)", len(this.Of), len(that1.Of))
	}
	for i := range this.Of {
		if this.Of[i] != that1.Of[i] {
			return fmt.Errorf("Of this[%v](%v) Not Equal that[%v](%v)", i, this.Of[i], i, that1.Of[i])
		}
	}
	return nil
}
func (this *AuthorizationGrant) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AuthorizationGrant)
	if !ok {
		that2, ok := that.(AuthorizationGrant)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.From.Equal(that1.From) {
		return false
	}
	if len(this.Of) != len(that1.Of) {
		return false
	}
	for i := range this.Of {
		if this.Of[i] != that1.Of[i] {
			return false
		}
	}
	return true
}
func (this *HistoryID) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*HistoryID)
	if !ok {
		that2, ok := that.(HistoryID)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *HistoryID")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *HistoryID but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *HistoryID but is not nil && this == nil")
	}
	if !this.ID.Equal(&that1.ID) {
		return fmt.Errorf("ID this(%v) Not Equal that(%v)", this.ID, that1.ID)
	}
	return nil
}
func (this *HistoryID) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*HistoryID)
	if !ok {
		that2, ok := that.(HistoryID)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.ID.Equal(&that1.ID) {
		return false
	}
	return true
}
func (this *HistoryItem) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*HistoryItem)
	if !ok {
		that2, ok := that.(HistoryItem)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *HistoryItem")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *HistoryItem but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *HistoryItem but is not nil && this == nil")
	}
	if this.Action != that1.Action {
		return fmt.Errorf("Action this(%v) Not Equal that(%v)", this.Action, that1.Action)
	}
	if !this.By.Equal(that1.By) {
		return fmt.Errorf("By this(%v) Not Equal that(%v)", this.By, that1.By)
	}
	if this.RequestData != that1.RequestData {
		return fmt.Errorf("RequestData this(%v) Not Equal that(%v)", this.RequestData, that1.RequestData)
	}
	if this.IPAddress != that1.IPAddress {
		return fmt.Errorf("IPAddress this(%v) Not Equal that(%v)", this.IPAddress, that1.IPAddress)
	}
	return nil
}
func (this *HistoryItem) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*HistoryItem)
	if !ok {
		that2, ok := that.(HistoryItem)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Action != that1.Action {
		return false
	}
	if !this.By.Equal(that1.By) {
		return false
	}
	if this.RequestData != that1.RequestData {
		return false
	}
	if this.IPAddress != that1.IPAddress {
		return false
	}
	return true
}
func (this *RegularUserID) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*RegularUserID)
	if !ok {
		that2, ok := that.(RegularUserID)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *RegularUserID")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *RegularUserID but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *RegularUserID but is not nil && this == nil")
	}
	if !this.ID.Equal(&that1.ID) {
		return fmt.Errorf("ID this(%v) Not Equal that(%v)", this.ID, that1.ID)
	}
	return nil
}
func (this *RegularUserID) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RegularUserID)
	if !ok {
		that2, ok := that.(RegularUserID)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.ID.Equal(&that1.ID) {
		return false
	}
	return true
}
func (this *UserID) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*UserID)
	if !ok {
		that2, ok := that.(UserID)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *UserID")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *UserID but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *UserID but is not nil && this == nil")
	}
	if that1.ID == nil {
		if this.ID != nil {
			return fmt.Errorf("this.ID != nil && that1.ID == nil")
		}
	} else if this.ID == nil {
		return fmt.Errorf("this.ID == nil && that1.ID != nil")
	} else if err := this.ID.VerboseEqual(that1.ID); err != nil {
		return err
	}
	return nil
}
func (this *UserID_SpecialUserID) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*UserID_SpecialUserID)
	if !ok {
		that2, ok := that.(UserID_SpecialUserID)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *UserID_SpecialUserID")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *UserID_SpecialUserID but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *UserID_SpecialUserID but is not nil && this == nil")
	}
	if this.SpecialUserID != that1.SpecialUserID {
		return fmt.Errorf("SpecialUserID this(%v) Not Equal that(%v)", this.SpecialUserID, that1.SpecialUserID)
	}
	return nil
}
func (this *UserID_RegularUserID) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*UserID_RegularUserID)
	if !ok {
		that2, ok := that.(UserID_RegularUserID)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *UserID_RegularUserID")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *UserID_RegularUserID but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *UserID_RegularUserID but is not nil && this == nil")
	}
	if !this.RegularUserID.Equal(that1.RegularUserID) {
		return fmt.Errorf("RegularUserID this(%v) Not Equal that(%v)", this.RegularUserID, that1.RegularUserID)
	}
	return nil
}
func (this *UserID) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*UserID)
	if !ok {
		that2, ok := that.(UserID)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.ID == nil {
		if this.ID != nil {
			return false
		}
	} else if this.ID == nil {
		return false
	} else if !this.ID.Equal(that1.ID) {
		return false
	}
	return true
}
func (this *UserID_SpecialUserID) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*UserID_SpecialUserID)
	if !ok {
		that2, ok := that.(UserID_SpecialUserID)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.SpecialUserID != that1.SpecialUserID {
		return false
	}
	return true
}
func (this *UserID_RegularUserID) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*UserID_RegularUserID)
	if !ok {
		that2, ok := that.(UserID_RegularUserID)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.RegularUserID.Equal(that1.RegularUserID) {
		return false
	}
	return true
}
func (this *RegularUser) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*RegularUser)
	if !ok {
		that2, ok := that.(RegularUser)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *RegularUser")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *RegularUser but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *RegularUser but is not nil && this == nil")
	}
	if !this.Id.Equal(that1.Id) {
		return fmt.Errorf("Id this(%v) Not Equal that(%v)", this.Id, that1.Id)
	}
	if this.Name != that1.Name {
		return fmt.Errorf("Name this(%v) Not Equal that(%v)", this.Name, that1.Name)
	}
	if len(this.Authorizations) != len(that1.Authorizations) {
		return fmt.Errorf("Authorizations this(%v) Not Equal that(%v)", len(this.Authorizations), len(that1.Authorizations))
	}
	for i := range this.Authorizations {
		if this.Authorizations[i] != that1.Authorizations[i] {
			return fmt.Errorf("Authorizations this[%v](%v) Not Equal that[%v](%v)", i, this.Authorizations[i], i, that1.Authorizations[i])
		}
	}
	if len(this.HistoryID) != len(that1.HistoryID) {
		return fmt.Errorf("HistoryID this(%v) Not Equal that(%v)", len(this.HistoryID), len(that1.HistoryID))
	}
	for i := range this.HistoryID {
		if !this.HistoryID[i].Equal(that1.HistoryID[i]) {
			return fmt.Errorf("HistoryID this[%v](%v) Not Equal that[%v](%v)", i, this.HistoryID[i], i, that1.HistoryID[i])
		}
	}
	if that1.Created == nil {
		if this.Created != nil {
			return fmt.Errorf("this.Created != nil && that1.Created == nil")
		}
	} else if !this.Created.Equal(*that1.Created) {
		return fmt.Errorf("Created this(%v) Not Equal that(%v)", this.Created, that1.Created)
	}
	return nil
}
func (this *RegularUser) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RegularUser)
	if !ok {
		that2, ok := that.(RegularUser)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Id.Equal(that1.Id) {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if len(this.Authorizations) != len(that1.Authorizations) {
		return false
	}
	for i := range this.Authorizations {
		if this.Authorizations[i] != that1.Authorizations[i] {
			return false
		}
	}
	if len(this.HistoryID) != len(that1.HistoryID) {
		return false
	}
	for i := range this.HistoryID {
		if !this.HistoryID[i].Equal(that1.HistoryID[i]) {
			return false
		}
	}
	if that1.Created == nil {
		if this.Created != nil {
			return false
		}
	} else if !this.Created.Equal(*that1.Created) {
		return false
	}
	return true
}
func (this *SpecialUser) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*SpecialUser)
	if !ok {
		that2, ok := that.(SpecialUser)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *SpecialUser")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *SpecialUser but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *SpecialUser but is not nil && this == nil")
	}
	if this.Id != that1.Id {
		return fmt.Errorf("Id this(%v) Not Equal that(%v)", this.Id, that1.Id)
	}
	if len(this.Authorizations) != len(that1.Authorizations) {
		return fmt.Errorf("Authorizations this(%v) Not Equal that(%v)", len(this.Authorizations), len(that1.Authorizations))
	}
	for i := range this.Authorizations {
		if this.Authorizations[i] != that1.Authorizations[i] {
			return fmt.Errorf("Authorizations this[%v](%v) Not Equal that[%v](%v)", i, this.Authorizations[i], i, that1.Authorizations[i])
		}
	}
	if len(this.HistoryID) != len(that1.HistoryID) {
		return fmt.Errorf("HistoryID this(%v) Not Equal that(%v)", len(this.HistoryID), len(that1.HistoryID))
	}
	for i := range this.HistoryID {
		if !this.HistoryID[i].Equal(that1.HistoryID[i]) {
			return fmt.Errorf("HistoryID this[%v](%v) Not Equal that[%v](%v)", i, this.HistoryID[i], i, that1.HistoryID[i])
		}
	}
	return nil
}
func (this *SpecialUser) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SpecialUser)
	if !ok {
		that2, ok := that.(SpecialUser)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Id != that1.Id {
		return false
	}
	if len(this.Authorizations) != len(that1.Authorizations) {
		return false
	}
	for i := range this.Authorizations {
		if this.Authorizations[i] != that1.Authorizations[i] {
			return false
		}
	}
	if len(this.HistoryID) != len(that1.HistoryID) {
		return false
	}
	for i := range this.HistoryID {
		if !this.HistoryID[i].Equal(that1.HistoryID[i]) {
			return false
		}
	}
	return true
}
func (this *ItemID) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*ItemID)
	if !ok {
		that2, ok := that.(ItemID)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *ItemID")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *ItemID but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *ItemID but is not nil && this == nil")
	}
	if !this.ID.Equal(&that1.ID) {
		return fmt.Errorf("ID this(%v) Not Equal that(%v)", this.ID, that1.ID)
	}
	return nil
}
func (this *ItemID) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ItemID)
	if !ok {
		that2, ok := that.(ItemID)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.ID.Equal(&that1.ID) {
		return false
	}
	return true
}
func (this *Item) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*Item)
	if !ok {
		that2, ok := that.(Item)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *Item")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *Item but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *Item but is not nil && this == nil")
	}
	if !this.Id.Equal(that1.Id) {
		return fmt.Errorf("Id this(%v) Not Equal that(%v)", this.Id, that1.Id)
	}
	if this.Name != that1.Name {
		return fmt.Errorf("Name this(%v) Not Equal that(%v)", this.Name, that1.Name)
	}
	if this.Location != that1.Location {
		return fmt.Errorf("Location this(%v) Not Equal that(%v)", this.Location, that1.Location)
	}
	if !this.Parent.Equal(that1.Parent) {
		return fmt.Errorf("Parent this(%v) Not Equal that(%v)", this.Parent, that1.Parent)
	}
	if len(this.Children) != len(that1.Children) {
		return fmt.Errorf("Children this(%v) Not Equal that(%v)", len(this.Children), len(that1.Children))
	}
	for i := range this.Children {
		if !this.Children[i].Equal(that1.Children[i]) {
			return fmt.Errorf("Children this[%v](%v) Not Equal that[%v](%v)", i, this.Children[i], i, that1.Children[i])
		}
	}
	return nil
}
func (this *Item) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Item)
	if !ok {
		that2, ok := that.(Item)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Id.Equal(that1.Id) {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if this.Location != that1.Location {
		return false
	}
	if !this.Parent.Equal(that1.Parent) {
		return false
	}
	if len(this.Children) != len(that1.Children) {
		return false
	}
	for i := range this.Children {
		if !this.Children[i].Equal(that1.Children[i]) {
			return false
		}
	}
	return true
}
func (this *OIDCProviderID) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*OIDCProviderID)
	if !ok {
		that2, ok := that.(OIDCProviderID)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *OIDCProviderID")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *OIDCProviderID but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *OIDCProviderID but is not nil && this == nil")
	}
	if !this.ID.Equal(&that1.ID) {
		return fmt.Errorf("ID this(%v) Not Equal that(%v)", this.ID, that1.ID)
	}
	return nil
}
func (this *OIDCProviderID) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*OIDCProviderID)
	if !ok {
		that2, ok := that.(OIDCProviderID)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.ID.Equal(&that1.ID) {
		return false
	}
	return true
}
func (this *OIDCProvider) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*OIDCProvider)
	if !ok {
		that2, ok := that.(OIDCProvider)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *OIDCProvider")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *OIDCProvider but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *OIDCProvider but is not nil && this == nil")
	}
	if !this.Id.Equal(that1.Id) {
		return fmt.Errorf("Id this(%v) Not Equal that(%v)", this.Id, that1.Id)
	}
	if this.Name != that1.Name {
		return fmt.Errorf("Name this(%v) Not Equal that(%v)", this.Name, that1.Name)
	}
	if this.Callback != that1.Callback {
		return fmt.Errorf("Callback this(%v) Not Equal that(%v)", this.Callback, that1.Callback)
	}
	if this.AuthorizationEndpoint != that1.AuthorizationEndpoint {
		return fmt.Errorf("AuthorizationEndpoint this(%v) Not Equal that(%v)", this.AuthorizationEndpoint, that1.AuthorizationEndpoint)
	}
	if this.ClientID != that1.ClientID {
		return fmt.Errorf("ClientID this(%v) Not Equal that(%v)", this.ClientID, that1.ClientID)
	}
	return nil
}
func (this *OIDCProvider) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*OIDCProvider)
	if !ok {
		that2, ok := that.(OIDCProvider)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Id.Equal(that1.Id) {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if this.Callback != that1.Callback {
		return false
	}
	if this.AuthorizationEndpoint != that1.AuthorizationEndpoint {
		return false
	}
	if this.ClientID != that1.ClientID {
		return false
	}
	return true
}
func (this *IDToken) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*IDToken)
	if !ok {
		that2, ok := that.(IDToken)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *IDToken")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *IDToken but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *IDToken but is not nil && this == nil")
	}
	if this.Issuer != that1.Issuer {
		return fmt.Errorf("Issuer this(%v) Not Equal that(%v)", this.Issuer, that1.Issuer)
	}
	if this.Subject != that1.Subject {
		return fmt.Errorf("Subject this(%v) Not Equal that(%v)", this.Subject, that1.Subject)
	}
	if this.Audience != that1.Audience {
		return fmt.Errorf("Audience this(%v) Not Equal that(%v)", this.Audience, that1.Audience)
	}
	if that1.Expiration == nil {
		if this.Expiration != nil {
			return fmt.Errorf("this.Expiration != nil && that1.Expiration == nil")
		}
	} else if !this.Expiration.Equal(*that1.Expiration) {
		return fmt.Errorf("Expiration this(%v) Not Equal that(%v)", this.Expiration, that1.Expiration)
	}
	if that1.Issued == nil {
		if this.Issued != nil {
			return fmt.Errorf("this.Issued != nil && that1.Issued == nil")
		}
	} else if !this.Issued.Equal(*that1.Issued) {
		return fmt.Errorf("Issued this(%v) Not Equal that(%v)", this.Issued, that1.Issued)
	}
	if this.Nonce != that1.Nonce {
		return fmt.Errorf("Nonce this(%v) Not Equal that(%v)", this.Nonce, that1.Nonce)
	}
	if this.AuthenticationContextClassReference != that1.AuthenticationContextClassReference {
		return fmt.Errorf("AuthenticationContextClassReference this(%v) Not Equal that(%v)", this.AuthenticationContextClassReference, that1.AuthenticationContextClassReference)
	}
	if len(this.AuthenticationMethodsReference) != len(that1.AuthenticationMethodsReference) {
		return fmt.Errorf("AuthenticationMethodsReference this(%v) Not Equal that(%v)", len(this.AuthenticationMethodsReference), len(that1.AuthenticationMethodsReference))
	}
	for i := range this.AuthenticationMethodsReference {
		if this.AuthenticationMethodsReference[i] != that1.AuthenticationMethodsReference[i] {
			return fmt.Errorf("AuthenticationMethodsReference this[%v](%v) Not Equal that[%v](%v)", i, this.AuthenticationMethodsReference[i], i, that1.AuthenticationMethodsReference[i])
		}
	}
	if this.AuthorizedParty != that1.AuthorizedParty {
		return fmt.Errorf("AuthorizedParty this(%v) Not Equal that(%v)", this.AuthorizedParty, that1.AuthorizedParty)
	}
	return nil
}
func (this *IDToken) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*IDToken)
	if !ok {
		that2, ok := that.(IDToken)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Issuer != that1.Issuer {
		return false
	}
	if this.Subject != that1.Subject {
		return false
	}
	if this.Audience != that1.Audience {
		return false
	}
	if that1.Expiration == nil {
		if this.Expiration != nil {
			return false
		}
	} else if !this.Expiration.Equal(*that1.Expiration) {
		return false
	}
	if that1.Issued == nil {
		if this.Issued != nil {
			return false
		}
	} else if !this.Issued.Equal(*that1.Issued) {
		return false
	}
	if this.Nonce != that1.Nonce {
		return false
	}
	if this.AuthenticationContextClassReference != that1.AuthenticationContextClassReference {
		return false
	}
	if len(this.AuthenticationMethodsReference) != len(that1.AuthenticationMethodsReference) {
		return false
	}
	for i := range this.AuthenticationMethodsReference {
		if this.AuthenticationMethodsReference[i] != that1.AuthenticationMethodsReference[i] {
			return false
		}
	}
	if this.AuthorizedParty != that1.AuthorizedParty {
		return false
	}
	return true
}
func (this *ID) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&types.ID{")
	s = append(s, "Id: "+fmt.Sprintf("%#v", this.Id)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *AuthorizationGrant) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&types.AuthorizationGrant{")
	if this.From != nil {
		s = append(s, "From: "+fmt.Sprintf("%#v", this.From)+",\n")
	}
	s = append(s, "Of: "+fmt.Sprintf("%#v", this.Of)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *HistoryID) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&types.HistoryID{")
	s = append(s, "ID: "+strings.Replace(this.ID.GoString(), `&`, ``, 1)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *HistoryItem) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&types.HistoryItem{")
	s = append(s, "Action: "+fmt.Sprintf("%#v", this.Action)+",\n")
	if this.By != nil {
		s = append(s, "By: "+fmt.Sprintf("%#v", this.By)+",\n")
	}
	s = append(s, "RequestData: "+fmt.Sprintf("%#v", this.RequestData)+",\n")
	s = append(s, "IPAddress: "+fmt.Sprintf("%#v", this.IPAddress)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *RegularUserID) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&types.RegularUserID{")
	s = append(s, "ID: "+strings.Replace(this.ID.GoString(), `&`, ``, 1)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *UserID) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&types.UserID{")
	if this.ID != nil {
		s = append(s, "ID: "+fmt.Sprintf("%#v", this.ID)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *UserID_SpecialUserID) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&types.UserID_SpecialUserID{` +
		`SpecialUserID:` + fmt.Sprintf("%#v", this.SpecialUserID) + `}`}, ", ")
	return s
}
func (this *UserID_RegularUserID) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&types.UserID_RegularUserID{` +
		`RegularUserID:` + fmt.Sprintf("%#v", this.RegularUserID) + `}`}, ", ")
	return s
}
func (this *RegularUser) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&types.RegularUser{")
	if this.Id != nil {
		s = append(s, "Id: "+fmt.Sprintf("%#v", this.Id)+",\n")
	}
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	s = append(s, "Authorizations: "+fmt.Sprintf("%#v", this.Authorizations)+",\n")
	if this.HistoryID != nil {
		s = append(s, "HistoryID: "+fmt.Sprintf("%#v", this.HistoryID)+",\n")
	}
	s = append(s, "Created: "+fmt.Sprintf("%#v", this.Created)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *SpecialUser) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&types.SpecialUser{")
	s = append(s, "Id: "+fmt.Sprintf("%#v", this.Id)+",\n")
	s = append(s, "Authorizations: "+fmt.Sprintf("%#v", this.Authorizations)+",\n")
	if this.HistoryID != nil {
		s = append(s, "HistoryID: "+fmt.Sprintf("%#v", this.HistoryID)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ItemID) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&types.ItemID{")
	s = append(s, "ID: "+strings.Replace(this.ID.GoString(), `&`, ``, 1)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Item) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&types.Item{")
	if this.Id != nil {
		s = append(s, "Id: "+fmt.Sprintf("%#v", this.Id)+",\n")
	}
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	s = append(s, "Location: "+fmt.Sprintf("%#v", this.Location)+",\n")
	if this.Parent != nil {
		s = append(s, "Parent: "+fmt.Sprintf("%#v", this.Parent)+",\n")
	}
	if this.Children != nil {
		s = append(s, "Children: "+fmt.Sprintf("%#v", this.Children)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *OIDCProviderID) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&types.OIDCProviderID{")
	s = append(s, "ID: "+strings.Replace(this.ID.GoString(), `&`, ``, 1)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *OIDCProvider) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&types.OIDCProvider{")
	if this.Id != nil {
		s = append(s, "Id: "+fmt.Sprintf("%#v", this.Id)+",\n")
	}
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	s = append(s, "Callback: "+fmt.Sprintf("%#v", this.Callback)+",\n")
	s = append(s, "AuthorizationEndpoint: "+fmt.Sprintf("%#v", this.AuthorizationEndpoint)+",\n")
	s = append(s, "ClientID: "+fmt.Sprintf("%#v", this.ClientID)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *IDToken) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 13)
	s = append(s, "&types.IDToken{")
	s = append(s, "Issuer: "+fmt.Sprintf("%#v", this.Issuer)+",\n")
	s = append(s, "Subject: "+fmt.Sprintf("%#v", this.Subject)+",\n")
	s = append(s, "Audience: "+fmt.Sprintf("%#v", this.Audience)+",\n")
	s = append(s, "Expiration: "+fmt.Sprintf("%#v", this.Expiration)+",\n")
	s = append(s, "Issued: "+fmt.Sprintf("%#v", this.Issued)+",\n")
	s = append(s, "Nonce: "+fmt.Sprintf("%#v", this.Nonce)+",\n")
	s = append(s, "AuthenticationContextClassReference: "+fmt.Sprintf("%#v", this.AuthenticationContextClassReference)+",\n")
	s = append(s, "AuthenticationMethodsReference: "+fmt.Sprintf("%#v", this.AuthenticationMethodsReference)+",\n")
	s = append(s, "AuthorizedParty: "+fmt.Sprintf("%#v", this.AuthorizedParty)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func valueToGoStringTypes(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}
func (m *ID) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ID) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ID) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AuthorizationGrant) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AuthorizationGrant) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AuthorizationGrant) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Of) > 0 {
		dAtA2 := make([]byte, len(m.Of)*10)
		var j1 int
		for _, num := range m.Of {
			for num >= 1<<7 {
				dAtA2[j1] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j1++
			}
			dAtA2[j1] = uint8(num)
			j1++
		}
		i -= j1
		copy(dAtA[i:], dAtA2[:j1])
		i = encodeVarintTypes(dAtA, i, uint64(j1))
		i--
		dAtA[i] = 0x12
	}
	if m.From != nil {
		{
			size, err := m.From.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *HistoryID) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HistoryID) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HistoryID) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.ID.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *HistoryItem) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HistoryItem) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HistoryItem) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.IPAddress) > 0 {
		i -= len(m.IPAddress)
		copy(dAtA[i:], m.IPAddress)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.IPAddress)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.RequestData) > 0 {
		i -= len(m.RequestData)
		copy(dAtA[i:], m.RequestData)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.RequestData)))
		i--
		dAtA[i] = 0x1a
	}
	if m.By != nil {
		{
			size, err := m.By.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Action) > 0 {
		i -= len(m.Action)
		copy(dAtA[i:], m.Action)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Action)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RegularUserID) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RegularUserID) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RegularUserID) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.ID.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *UserID) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UserID) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UserID) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ID != nil {
		{
			size := m.ID.Size()
			i -= size
			if _, err := m.ID.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *UserID_SpecialUserID) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *UserID_SpecialUserID) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i = encodeVarintTypes(dAtA, i, uint64(m.SpecialUserID))
	i--
	dAtA[i] = 0x8
	return len(dAtA) - i, nil
}
func (m *UserID_RegularUserID) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *UserID_RegularUserID) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.RegularUserID != nil {
		{
			size, err := m.RegularUserID.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *RegularUser) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RegularUser) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RegularUser) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Created != nil {
		n8, err8 := github_com_gogo_protobuf_types.StdTimeMarshalTo(*m.Created, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdTime(*m.Created):])
		if err8 != nil {
			return 0, err8
		}
		i -= n8
		i = encodeVarintTypes(dAtA, i, uint64(n8))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.HistoryID) > 0 {
		for iNdEx := len(m.HistoryID) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.HistoryID[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.Authorizations) > 0 {
		dAtA10 := make([]byte, len(m.Authorizations)*10)
		var j9 int
		for _, num := range m.Authorizations {
			for num >= 1<<7 {
				dAtA10[j9] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j9++
			}
			dAtA10[j9] = uint8(num)
			j9++
		}
		i -= j9
		copy(dAtA[i:], dAtA10[:j9])
		i = encodeVarintTypes(dAtA, i, uint64(j9))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if m.Id != nil {
		{
			size, err := m.Id.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SpecialUser) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SpecialUser) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SpecialUser) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.HistoryID) > 0 {
		for iNdEx := len(m.HistoryID) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.HistoryID[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Authorizations) > 0 {
		dAtA13 := make([]byte, len(m.Authorizations)*10)
		var j12 int
		for _, num := range m.Authorizations {
			for num >= 1<<7 {
				dAtA13[j12] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j12++
			}
			dAtA13[j12] = uint8(num)
			j12++
		}
		i -= j12
		copy(dAtA[i:], dAtA13[:j12])
		i = encodeVarintTypes(dAtA, i, uint64(j12))
		i--
		dAtA[i] = 0x12
	}
	if m.Id != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ItemID) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ItemID) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ItemID) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.ID.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *Item) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Item) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Item) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Children) > 0 {
		for iNdEx := len(m.Children) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Children[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if m.Parent != nil {
		{
			size, err := m.Parent.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if len(m.Location) > 0 {
		i -= len(m.Location)
		copy(dAtA[i:], m.Location)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Location)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if m.Id != nil {
		{
			size, err := m.Id.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *OIDCProviderID) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OIDCProviderID) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OIDCProviderID) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.ID.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *OIDCProvider) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OIDCProvider) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OIDCProvider) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ClientID) > 0 {
		i -= len(m.ClientID)
		copy(dAtA[i:], m.ClientID)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.ClientID)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.AuthorizationEndpoint) > 0 {
		i -= len(m.AuthorizationEndpoint)
		copy(dAtA[i:], m.AuthorizationEndpoint)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.AuthorizationEndpoint)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Callback) > 0 {
		i -= len(m.Callback)
		copy(dAtA[i:], m.Callback)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Callback)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if m.Id != nil {
		{
			size, err := m.Id.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *IDToken) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IDToken) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IDToken) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.AuthorizedParty) > 0 {
		i -= len(m.AuthorizedParty)
		copy(dAtA[i:], m.AuthorizedParty)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.AuthorizedParty)))
		i--
		dAtA[i] = 0x4a
	}
	if len(m.AuthenticationMethodsReference) > 0 {
		for iNdEx := len(m.AuthenticationMethodsReference) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.AuthenticationMethodsReference[iNdEx])
			copy(dAtA[i:], m.AuthenticationMethodsReference[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.AuthenticationMethodsReference[iNdEx])))
			i--
			dAtA[i] = 0x42
		}
	}
	if m.AuthenticationContextClassReference != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.AuthenticationContextClassReference))
		i--
		dAtA[i] = 0x38
	}
	if len(m.Nonce) > 0 {
		i -= len(m.Nonce)
		copy(dAtA[i:], m.Nonce)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Nonce)))
		i--
		dAtA[i] = 0x32
	}
	if m.Issued != nil {
		n19, err19 := github_com_gogo_protobuf_types.StdTimeMarshalTo(*m.Issued, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdTime(*m.Issued):])
		if err19 != nil {
			return 0, err19
		}
		i -= n19
		i = encodeVarintTypes(dAtA, i, uint64(n19))
		i--
		dAtA[i] = 0x2a
	}
	if m.Expiration != nil {
		n20, err20 := github_com_gogo_protobuf_types.StdTimeMarshalTo(*m.Expiration, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdTime(*m.Expiration):])
		if err20 != nil {
			return 0, err20
		}
		i -= n20
		i = encodeVarintTypes(dAtA, i, uint64(n20))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Audience) > 0 {
		i -= len(m.Audience)
		copy(dAtA[i:], m.Audience)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Audience)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Subject) > 0 {
		i -= len(m.Subject)
		copy(dAtA[i:], m.Subject)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Subject)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Issuer) > 0 {
		i -= len(m.Issuer)
		copy(dAtA[i:], m.Issuer)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Issuer)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintTypes(dAtA []byte, offset int, v uint64) int {
	offset -= sovTypes(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *ID) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *AuthorizationGrant) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.From != nil {
		l = m.From.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.Of) > 0 {
		l = 0
		for _, e := range m.Of {
			l += sovTypes(uint64(e))
		}
		n += 1 + sovTypes(uint64(l)) + l
	}
	return n
}

func (m *HistoryID) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.ID.Size()
	n += 1 + l + sovTypes(uint64(l))
	return n
}

func (m *HistoryItem) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Action)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.By != nil {
		l = m.By.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.RequestData)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.IPAddress)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *RegularUserID) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.ID.Size()
	n += 1 + l + sovTypes(uint64(l))
	return n
}

func (m *UserID) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ID != nil {
		n += m.ID.Size()
	}
	return n
}

func (m *UserID_SpecialUserID) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovTypes(uint64(m.SpecialUserID))
	return n
}
func (m *UserID_RegularUserID) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RegularUserID != nil {
		l = m.RegularUserID.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *RegularUser) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != nil {
		l = m.Id.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.Authorizations) > 0 {
		l = 0
		for _, e := range m.Authorizations {
			l += sovTypes(uint64(e))
		}
		n += 1 + sovTypes(uint64(l)) + l
	}
	if len(m.HistoryID) > 0 {
		for _, e := range m.HistoryID {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.Created != nil {
		l = github_com_gogo_protobuf_types.SizeOfStdTime(*m.Created)
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *SpecialUser) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovTypes(uint64(m.Id))
	}
	if len(m.Authorizations) > 0 {
		l = 0
		for _, e := range m.Authorizations {
			l += sovTypes(uint64(e))
		}
		n += 1 + sovTypes(uint64(l)) + l
	}
	if len(m.HistoryID) > 0 {
		for _, e := range m.HistoryID {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *ItemID) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.ID.Size()
	n += 1 + l + sovTypes(uint64(l))
	return n
}

func (m *Item) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != nil {
		l = m.Id.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Location)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Parent != nil {
		l = m.Parent.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.Children) > 0 {
		for _, e := range m.Children {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *OIDCProviderID) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.ID.Size()
	n += 1 + l + sovTypes(uint64(l))
	return n
}

func (m *OIDCProvider) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != nil {
		l = m.Id.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Callback)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.AuthorizationEndpoint)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.ClientID)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *IDToken) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Issuer)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Subject)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Audience)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Expiration != nil {
		l = github_com_gogo_protobuf_types.SizeOfStdTime(*m.Expiration)
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Issued != nil {
		l = github_com_gogo_protobuf_types.SizeOfStdTime(*m.Issued)
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Nonce)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.AuthenticationContextClassReference != 0 {
		n += 1 + sovTypes(uint64(m.AuthenticationContextClassReference))
	}
	if len(m.AuthenticationMethodsReference) > 0 {
		for _, s := range m.AuthenticationMethodsReference {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	l = len(m.AuthorizedParty)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func sovTypes(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozTypes(x uint64) (n int) {
	return sovTypes(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *ID) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ID{`,
		`Id:` + fmt.Sprintf("%v", this.Id) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AuthorizationGrant) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AuthorizationGrant{`,
		`From:` + strings.Replace(this.From.String(), "UserID", "UserID", 1) + `,`,
		`Of:` + fmt.Sprintf("%v", this.Of) + `,`,
		`}`,
	}, "")
	return s
}
func (this *HistoryID) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&HistoryID{`,
		`ID:` + strings.Replace(strings.Replace(this.ID.String(), "ID", "ID", 1), `&`, ``, 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *HistoryItem) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&HistoryItem{`,
		`Action:` + fmt.Sprintf("%v", this.Action) + `,`,
		`By:` + strings.Replace(this.By.String(), "UserID", "UserID", 1) + `,`,
		`RequestData:` + fmt.Sprintf("%v", this.RequestData) + `,`,
		`IPAddress:` + fmt.Sprintf("%v", this.IPAddress) + `,`,
		`}`,
	}, "")
	return s
}
func (this *RegularUserID) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&RegularUserID{`,
		`ID:` + strings.Replace(strings.Replace(this.ID.String(), "ID", "ID", 1), `&`, ``, 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *UserID) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&UserID{`,
		`ID:` + fmt.Sprintf("%v", this.ID) + `,`,
		`}`,
	}, "")
	return s
}
func (this *UserID_SpecialUserID) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&UserID_SpecialUserID{`,
		`SpecialUserID:` + fmt.Sprintf("%v", this.SpecialUserID) + `,`,
		`}`,
	}, "")
	return s
}
func (this *UserID_RegularUserID) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&UserID_RegularUserID{`,
		`RegularUserID:` + strings.Replace(fmt.Sprintf("%v", this.RegularUserID), "RegularUserID", "RegularUserID", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *RegularUser) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForHistoryID := "[]*HistoryID{"
	for _, f := range this.HistoryID {
		repeatedStringForHistoryID += strings.Replace(f.String(), "HistoryID", "HistoryID", 1) + ","
	}
	repeatedStringForHistoryID += "}"
	s := strings.Join([]string{`&RegularUser{`,
		`Id:` + strings.Replace(this.Id.String(), "UserID", "UserID", 1) + `,`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`Authorizations:` + fmt.Sprintf("%v", this.Authorizations) + `,`,
		`HistoryID:` + repeatedStringForHistoryID + `,`,
		`Created:` + strings.Replace(fmt.Sprintf("%v", this.Created), "Timestamp", "types.Timestamp", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *SpecialUser) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForHistoryID := "[]*HistoryID{"
	for _, f := range this.HistoryID {
		repeatedStringForHistoryID += strings.Replace(f.String(), "HistoryID", "HistoryID", 1) + ","
	}
	repeatedStringForHistoryID += "}"
	s := strings.Join([]string{`&SpecialUser{`,
		`Id:` + fmt.Sprintf("%v", this.Id) + `,`,
		`Authorizations:` + fmt.Sprintf("%v", this.Authorizations) + `,`,
		`HistoryID:` + repeatedStringForHistoryID + `,`,
		`}`,
	}, "")
	return s
}
func (this *ItemID) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ItemID{`,
		`ID:` + strings.Replace(strings.Replace(this.ID.String(), "ID", "ID", 1), `&`, ``, 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Item) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForChildren := "[]*ItemID{"
	for _, f := range this.Children {
		repeatedStringForChildren += strings.Replace(f.String(), "ItemID", "ItemID", 1) + ","
	}
	repeatedStringForChildren += "}"
	s := strings.Join([]string{`&Item{`,
		`Id:` + strings.Replace(this.Id.String(), "ItemID", "ItemID", 1) + `,`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`Location:` + fmt.Sprintf("%v", this.Location) + `,`,
		`Parent:` + strings.Replace(this.Parent.String(), "ItemID", "ItemID", 1) + `,`,
		`Children:` + repeatedStringForChildren + `,`,
		`}`,
	}, "")
	return s
}
func (this *OIDCProviderID) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&OIDCProviderID{`,
		`ID:` + strings.Replace(strings.Replace(this.ID.String(), "ID", "ID", 1), `&`, ``, 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *OIDCProvider) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&OIDCProvider{`,
		`Id:` + strings.Replace(this.Id.String(), "OIDCProviderID", "OIDCProviderID", 1) + `,`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`Callback:` + fmt.Sprintf("%v", this.Callback) + `,`,
		`AuthorizationEndpoint:` + fmt.Sprintf("%v", this.AuthorizationEndpoint) + `,`,
		`ClientID:` + fmt.Sprintf("%v", this.ClientID) + `,`,
		`}`,
	}, "")
	return s
}
func (this *IDToken) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&IDToken{`,
		`Issuer:` + fmt.Sprintf("%v", this.Issuer) + `,`,
		`Subject:` + fmt.Sprintf("%v", this.Subject) + `,`,
		`Audience:` + fmt.Sprintf("%v", this.Audience) + `,`,
		`Expiration:` + strings.Replace(fmt.Sprintf("%v", this.Expiration), "Timestamp", "types.Timestamp", 1) + `,`,
		`Issued:` + strings.Replace(fmt.Sprintf("%v", this.Issued), "Timestamp", "types.Timestamp", 1) + `,`,
		`Nonce:` + fmt.Sprintf("%v", this.Nonce) + `,`,
		`AuthenticationContextClassReference:` + fmt.Sprintf("%v", this.AuthenticationContextClassReference) + `,`,
		`AuthenticationMethodsReference:` + fmt.Sprintf("%v", this.AuthenticationMethodsReference) + `,`,
		`AuthorizedParty:` + fmt.Sprintf("%v", this.AuthorizedParty) + `,`,
		`}`,
	}, "")
	return s
}
func valueToStringTypes(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *ID) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ID: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ID: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AuthorizationGrant) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AuthorizationGrant: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AuthorizationGrant: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field From", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.From == nil {
				m.From = &UserID{}
			}
			if err := m.From.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType == 0 {
				var v Authorization
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= Authorization(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Of = append(m.Of, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTypes
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthTypes
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				if elementCount != 0 && len(m.Of) == 0 {
					m.Of = make([]Authorization, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v Authorization
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= Authorization(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Of = append(m.Of, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Of", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HistoryID) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HistoryID: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HistoryID: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ID.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HistoryItem) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HistoryItem: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HistoryItem: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Action", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Action = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field By", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.By == nil {
				m.By = &UserID{}
			}
			if err := m.By.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestData", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RequestData = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IPAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IPAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RegularUserID) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RegularUserID: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RegularUserID: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ID.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UserID) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UserID: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UserID: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SpecialUserID", wireType)
			}
			var v SpecialUserID
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= SpecialUserID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ID = &UserID_SpecialUserID{v}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RegularUserID", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &RegularUserID{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ID = &UserID_RegularUserID{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RegularUser) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RegularUser: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RegularUser: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Id == nil {
				m.Id = &UserID{}
			}
			if err := m.Id.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType == 0 {
				var v Authorization
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= Authorization(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Authorizations = append(m.Authorizations, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTypes
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthTypes
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				if elementCount != 0 && len(m.Authorizations) == 0 {
					m.Authorizations = make([]Authorization, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v Authorization
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= Authorization(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Authorizations = append(m.Authorizations, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Authorizations", wireType)
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HistoryID", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HistoryID = append(m.HistoryID, &HistoryID{})
			if err := m.HistoryID[len(m.HistoryID)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Created", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Created == nil {
				m.Created = new(time.Time)
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(m.Created, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SpecialUser) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SpecialUser: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SpecialUser: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= SpecialUserID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType == 0 {
				var v Authorization
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= Authorization(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Authorizations = append(m.Authorizations, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTypes
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthTypes
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				if elementCount != 0 && len(m.Authorizations) == 0 {
					m.Authorizations = make([]Authorization, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v Authorization
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= Authorization(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Authorizations = append(m.Authorizations, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Authorizations", wireType)
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HistoryID", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HistoryID = append(m.HistoryID, &HistoryID{})
			if err := m.HistoryID[len(m.HistoryID)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ItemID) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ItemID: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ItemID: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ID.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Item) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Item: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Item: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Id == nil {
				m.Id = &ItemID{}
			}
			if err := m.Id.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Location", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Location = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Parent", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Parent == nil {
				m.Parent = &ItemID{}
			}
			if err := m.Parent.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Children", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Children = append(m.Children, &ItemID{})
			if err := m.Children[len(m.Children)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OIDCProviderID) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OIDCProviderID: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OIDCProviderID: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ID.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OIDCProvider) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OIDCProvider: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OIDCProvider: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Id == nil {
				m.Id = &OIDCProviderID{}
			}
			if err := m.Id.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Callback", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Callback = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthorizationEndpoint", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AuthorizationEndpoint = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClientID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IDToken) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IDToken: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IDToken: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Issuer", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Issuer = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Subject", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Subject = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Audience", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Audience = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Expiration", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Expiration == nil {
				m.Expiration = new(time.Time)
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(m.Expiration, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Issued", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Issued == nil {
				m.Issued = new(time.Time)
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(m.Issued, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nonce", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Nonce = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthenticationContextClassReference", wireType)
			}
			m.AuthenticationContextClassReference = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AuthenticationContextClassReference |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthenticationMethodsReference", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AuthenticationMethodsReference = append(m.AuthenticationMethodsReference, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthorizedParty", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AuthorizedParty = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTypes(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthTypes
			}
			iNdEx += length
			if iNdEx < 0 {
				return 0, ErrInvalidLengthTypes
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipTypes(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
				if iNdEx < 0 {
					return 0, ErrInvalidLengthTypes
				}
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthTypes = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTypes   = fmt.Errorf("proto: integer overflow")
)
